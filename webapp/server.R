require(shiny)
require(shinydashboard)
require(rCharts)
require(dygraphs)
require(xts)
require(d3heatmap)
require(ggplot2)
require(plyr)
require(googleVis)
require(networkD3)
require(shinyjs)
require(tm)
require(wordcloud)
require(DT)
require(R.utils)
require(RMySQL)
require(tools)
require(gdata)
require(plotly)
require(rjson)
source("config.R")

source("learner_filters.R")
source("courses.R")
source("data_retrieval.R")

jscode <- "
shinyjs.collapse = function(boxid) {
$('#' + boxid).closest('.box').find('[data-widget=collapse]').click();
}
"

#' Title
#'
#' @param input 
#' @param output 
#' @param session 
#'
#' @return
#' @export
#'
#' @examples
function(input, output, session) { 
  source("learner_analysis.R", local=TRUE)
  output$institution <- renderText({"soton"})
  output$pageTitle <- renderText("Welcome to the MOOC Dashboard! Select the course(s) and run(s) you wish to visualise")
  # output$updatedTime <- renderText(paste("Data last updated  -  ",getUpdatedTime()))
  
  # Make the text inputs of the active filters read-only and hide the dummy inputs
  shinyjs::disable("gender")
  shinyjs::disable("age")
  shinyjs::disable("selected")
  shinyjs::disable("emplArea")
  shinyjs::disable("emplStatus")
  shinyjs::disable("degree")
  shinyjs::disable("foundCourse")
  shinyjs::disable("hopeCourse")
  shinyjs::disable("experience")
  shinyjs::disable("methods")
  shinyjs::disable("subjects")
  shinyjs::disable("place")
  shinyjs::hide("filteredLearners")
  shinyjs::hide("filteredStreams")
  shinyjs::hide("scatterSlopeValue")
  
  # Load the meta data.
  courseMetaData <- getCourseMetaData()
  
  # Load the necessary data from the SQL database for each of the runs, store the types of data,
  # step data, comment data, enrolment data, quiz data, review data, course meta data, team data for each of the 
  # runs in a list of data frames
  # Executes after user has clicked the "chooseCourseButton"
  step_data <- NULL
  comments_data <- NULL
  quiz_data <- NULL
  assignments_data <- NULL
  reviews_data <- NULL
  enrolment_data <- NULL
  course_data <- NULL
  team_data <- NULL
  
  observeEvent(input$chooseCourseButton, {
    
    withProgress(message = "Loading Data", value = 0, {
      
      #Updates the page title to contain the courses and runs selected
      output$pageTitle <- renderText(paste(input$course1, "- [", strsplit(input$run1," - ")[[1]][1], "]",
                                           ifelse(input$run2 != "None",paste0(" vs ",input$course2,"- [", strsplit(input$run2," - ")[[1]][1], "]"),""),
                                           ifelse(input$run3 != "None",paste0(" vs ",input$course3,"- [", strsplit(input$run3," - ")[[1]][1], "]"),""),
                                           ifelse(input$run4 != "None",paste0(" vs ",input$course4,"- [", strsplit(input$run4," - ")[[1]][1], "]"),"")))
      
      #Updates the app to show the demographics page after loading a course
      updateTabsetPanel(session, "tabs", selected = "demographics")
      
      #FixMe - this could all go into a function - but check scope
      
      #number of steps in the loading part
      n <- 9
      
      #getting the data from the database and storing it into a global variable
      #updating the loading progress
      #same process repeated for each variable
      stepDataFiles <- getData("Activity")
      step_data <<- stepDataFiles
      incProgress(1/n, detail = "Loaded Step Data")
      
      commentsDataFiles <- getData("Comments")
      comments_data <<- commentsDataFiles
      incProgress(1/n, detail = "Loaded Comment Data")
      
      quizDataFiles <- getData("Quiz")
      quiz_data <<- quizDataFiles
      incProgress(1/n, detail = "Loaded Quiz Data")
      
      assignmentsDataFiles <- getData("Assignments")
      assignments_data <<- assignmentsDataFiles
      incProgress(1/n, detail = "Loaded assignment Data")
      
      reviewsDataFiles <- getData("Reviews")
      reviews_data <<- reviewsDataFiles
      incProgress(1/n, detail = "Loaded Review Data")
      
      enrolmentsDataFiles <- getData("Enrolments")
      enrolment_data <<- enrolmentsDataFiles
      incProgress(1/n, detail = "Loaded Enrolments Data")
      
      courseMetaData <- getCourseData()
      course_data <<- courseMetaData
      incProgress(1/n, detail = "Loaded Meta Data")
      
      teamDataFiles <- getAllTableData("TeamMembers")
      team_data <<- teamDataFiles
      incProgress(1/n, detail = "Loaded Team Members Data")
      
      assign("pre_course_data", do.call("rbind",enrolment_data) , envir = .GlobalEnv)
      assign("allLearners", getAllLearners(enrolmentsDataFiles), envir = .GlobalEnv)
      assign("filtersEnabled", FALSE, envir = .GlobalEnv)
      updateTextInput(session, "filteredLearners", value = allLearners)
      
      incProgress(1/n, detail = "Finished")
      
    })
    
  }, priority = 10)
  
  
  
  
  # Runs SQL queries for each of the selected runs with the sql table to query as a parameter
  # and returns the data as a list of dataframes
  getData <- function(table){
    data1 <- getTable(table, input$course1,input$run1)
    name <- paste(c(input$course1,strsplit(input$run1," - ")[[1]][1]), collapse = " - ")
    datasets <- list("1"= data1)
    names(datasets)[which(names(datasets) == "1")] <- name
    if(input$run2 != "None"){
      data2 <- getTable(table, input$course2,input$run2)
      datasets[[paste(c(input$course2,strsplit(input$run2," - ")[[1]][1]), collapse = " - ")]] <- data2
    }
    if(input$run3 != "None"){
      data3 <- getTable(table, input$course3,input$run3)
      datasets[[paste(c(input$course3,strsplit(input$run3," - ")[[1]][1]), collapse = " - ")]] <- data3
    }
    if(input$run4 != "None"){
      data4 <- getTable(table, input$course4,input$run4)
      datasets[[paste(c(input$course4,strsplit(input$run4," - ")[[1]][1]), collapse = " - ")]] <- data4
    }
    return(datasets)
  }
  
  # Queries the course meta data table
  getCourseData <- function(){
    run1 <- strsplit(input$run1," - ")[[1]][1]
    if(run1 != "All"){
      data1 <- getCourseMetaDataSpecific(input$course1,run1)
      name <- paste(c(input$course1,run1), collapse = " - ")
      datasets <- list("1"= data1)
      names(datasets)[which(names(datasets) == "1")] <- name
    } else {
      datasets <- list()
    }
    run2 <- strsplit(input$run2," - ")[[1]][1]
    if(input$run2 != "None" &  run2 != "All"){
      data2 <- getCourseMetaDataSpecific(input$course2, run2)
      datasets[[paste(c(input$course2,run2), collapse = " - ")]] <- data2
    }
    run3 <- strsplit(input$run3," - ")[[1]][1]
    if(input$run3 != "None" & run3 != "All"){
      data3 <- getCourseMetaDataSpecific(input$course3, run3)
      datasets[[paste(c(input$course3,strsplit(input$run3," - ")[[1]][1]), collapse = " - ")]] <- data3
    }
    run4 <- strsplit(input$run4," - ")[[1]][1]
    if(input$run4 != "None" & run4 != "All"){
      data4 <- getCourseMetaDataSpecific(input$course4, run4)
      datasets[[paste(c(input$course4,run4), collapse = " - ")]] <- data4
    }
    return(datasets)
  }
  
  #Needs to be converted to use getMetaData
  # aggregateEnrol <- read.csv(file.path(getwd(),"../data",institution,"Courses Data","Deets","Courses-Data.csv"))
  # assign("aggregateEnrol", aggregateEnrol, envir = .GlobalEnv) 
  
  # Various Dependencies which stop graphs from attemping to be created without the required data selected first.
  chartDependency <- eventReactive(input$chooseCourseButton, {})
  stepDependancy <- eventReactive(input$runChooserSteps, {})
  commentDependancy <- eventReactive(input$runChooserComments, {})
  commentTypeDependancy <- eventReactive(input$runChooserCommentsType, {})
  measuresDependancy <- eventReactive(input$totalMeasuresRunChooser, {})
  
  
  #START: COURSE SELECTION UI AND VALUE BOXES
  
  print("About to assemble runs")
  output$runs1 <-renderUI({
    runs <- getRuns(input$course1)
    start_dates <- getStartDates(input$course1)
    num_of_weeks <- getNoOfWeeks(input$course1)
    
    #Using the start dates and number of weeks to find out the end dates
    end_date <- as.Date(start_dates) + as.integer(num_of_weeks)*7
    selectInput("run1", label = "Run", width = "450px", choices = c("All", paste(runs, start_dates, end_date, sep = " - ")))
  })
  output$runs2 <-renderUI({
    
    runs <- getRuns(input$course2)
    start_dates <- getStartDates(input$course2)
    num_of_weeks <- getNoOfWeeks(input$course2)
    
    #Using the start dates and number of weeks to find out the end dates
    end_date <- as.Date(start_dates) + as.integer(num_of_weeks)*7
    
    selectInput("run2", label = "Run", width = "450px", choices = c("None", "All", paste(runs, start_dates, end_date, sep = " - ")))
  })
  output$runs3 <-renderUI({
    runs <- getRuns(input$course3)
    start_dates <- getStartDates(input$course3)
    num_of_weeks <- getNoOfWeeks(input$course3)
    
    #Using the start dates and number of weeks to find out the end dates
    end_date <- as.Date(start_dates) + as.integer(num_of_weeks)*7
    selectInput("run3", label = "Run", width = "450px", choices = c("None", "All", paste(runs, start_dates, end_date, sep = " - ")))
  })
  output$runs4 <-renderUI({
    runs <- getRuns(input$course4)
    start_dates <- getStartDates(input$course4)
    num_of_weeks <- getNoOfWeeks(input$course4)
    
    #Using the start dates and number of weeks to find out the end dates
    end_date <- as.Date(start_dates) + as.integer(num_of_weeks)*7
    selectInput("run4", label = "Run", width = "450px", choices = c("None", "All", paste(runs, start_dates, end_date, sep = " - ")))
  })
  
  output$chooseCourse <- renderUI({
    actionButton("chooseCourseButton", label = "Go")
  })
  
  output$enrolmentCount <- renderValueBox({
    chartDependency()
    learners <- unlist(strsplit(input$filteredLearners, "[,]"))
    count <- getEnrolmentCount(enrolment_data[[1]])   
    valueBox("Enrolled", count, icon = icon("line-chart"), color = "blue")
  })
  
  output$completedCount <- renderValueBox({
    chartDependency()
    learners <- unlist(strsplit(input$filteredLearners, "[,]"))
    count <- getCompletionCount(step_data)
    valueBox("Completed", count, icon = icon("list"), color = "purple")
  })
  
  output$courseDuration <- renderValueBox({
    chartDependency()
    valueBox("Duration", paste(courseDates[3], "weeks"), icon = icon("clock-o"), color = "aqua")
  })
  
  output$courseStart <- renderValueBox({
    chartDependency()
    valueBox("Start date", courseDates[1], icon = icon("calendar"), color = "yellow")
  })
  
  # outputs in a value box the number of total comments in the current course run
  output$totalComments <- renderValueBox({
    
    # to update the value when the button to change course run is pressed or the selected course in the dropdown changes
    chartDependency()
    measuresDependancy()
    learners <- unlist(strsplit(input$filteredLearners, "[,]"))
    
    # comment data for the selected course run
    cData <- comments_data[[which(names(comments_data)==input$totalMeasuresRunChooser)]]
    
    # checks if there exists comment data and updates the valueBox
    if(nrow(cData)!=0) {
      comments <- getNumberOfCommentsByLearner(cData)
      comments <- sum(comments$comments)
    } else {
      comments <- 0
    }
    valueBox("Comments", paste(comments, "in total"), icon = icon("comment-o"), color = "red")
  })
  
  
  # outputs in a value box the number of total replies in the current course run
  output$totalReplies <- renderValueBox({
    
    # to update the value when the button to change course run is pressed or the selected course in the dropdown changes
    chartDependency()
    measuresDependancy()
    learners <- unlist(strsplit(input$filteredLearners, "[,]"))
    
    # comment data for the selected course run
    cData <- comments_data[[which(names(comments_data)==input$totalMeasuresRunChooser)]]
    
    # checks if there exists comment data and updates the valueBox
    if(nrow(cData)!=0){
      replies <- getNumberOfRepliesByLearner(cData)
      replies <- sum(replies$replies)
    } else {
      replies <-0
    }
    valueBox("Replies", paste(replies, "in total"), icon = icon("reply"), color = "yellow")
  })
  
  
  # outputs in a value box the average number of comments in the current course run
  output$avgComments <- renderValueBox({
    
    # to update the value when the button to change course run is pressed or the selected course in the dropdown changes
    chartDependency()
    measuresDependancy()
    learners <- unlist(strsplit(input$filteredLearners, "[,]"))
    
    #comment data for the selected course run
    cData <- comments_data[[which(names(comments_data)==input$totalMeasuresRunChooser)]]
    
    #checks if there is any available comment data and computes the value box
    if(nrow(cData)!=0){
      comments <- getNumberOfCommentsByLearner(cData)
      comments <- median(comments$comments)
    } else {
      comments <- 0
    }
    valueBox("Comments", paste(comments, "average per learner"), icon = icon("comment-o"), color = "green")
  })
  
  
  # outputs in a value box the average number of replies in the current course run
  output$avgReplies <- renderValueBox({
    
    # to update the value when the button to change course run is pressed or the selected course in the dropdown changes
    chartDependency()
    measuresDependancy()
    learners <- unlist(strsplit(input$filteredLearners, "[,]"))
    
    #comment data for the selected course run
    cData <- comments_data[[which(names(comments_data)==input$totalMeasuresRunChooser)]]
    
    #checks if there is any available comment data and computes the value box
    if(nrow(cData)!=0){
      replies <- getNumberOfRepliesByLearner(cData)
      replies <- median(replies$replies)
    } else {
      replies <- 0
    }
    valueBox("Replies", paste(replies, "average per learner"), icon = icon("reply"), color = "olive")
  })
  
  observeEvent(input$scatterSlopeValue, {
    output$scatterSlope <- renderValueBox({
      chartDependency()
      input$plotScatterButton
      valueBox("Slope", input$scatterSlopeValue, icon = icon("line-chart"), color = "red", width = 12)
    })
  })
  
  
  #END: COURSE SELECTION UI AND VALUE BOXES
  
  
  # =================================START NOT USED===============================================
  #START: LEARNER FILTERS - TEXT INPUTS - NOT USED
  observeEvent(input$click$genderFilter, {
    updateTextInput(session, "gender", value = input$click$genderFilter)
  })
  
  observeEvent(input$click$ageFilter, {
    updateTextInput(session, "age", value = input$click$ageFilter)
  })
  
  observeEvent(input$click$employmentAreaFilter, {
    updateTextInput(session, "emplArea", value = input$click$employmentAreaFilter)
  })
  
  observeEvent(input$click$employmentStatusFilter, {
    updateTextInput(session, "emplStatus", value = input$click$employmentStatusFilter)
  })
  
  observeEvent(input$click$degreeFilter, {
    updateTextInput(session, "degree", value = input$click$degreeFilter)
  })
  
  observeEvent(input$click$foundCourseFilter, {
    updateTextInput(session, "foundCourse", value = input$click$foundCourseFilter)
  })
  
  observeEvent(input$click$hopeCourseFilter, {
    updateTextInput(session, "hopeCourse", value = input$click$hopeCourseFilter)
  })
  
  observeEvent(input$click$experienceFilter, {
    updateTextInput(session, "experience", value = input$click$experienceFilter)
  })
  
  observeEvent(input$click$methodsFilter, {
    updateTextInput(session, "methods", value = input$click$methodsFilter)
  })
  
  observeEvent(input$click$subjectsFilter, {
    updateTextInput(session, "subjects", value = input$click$subjectsFilter)
  })
  
  observeEvent(input$click$placeFilter, {
    updateTextInput(session, "place", value = input$click$placeFilter)
  })
  
  output$selected <- renderText({
    input$selected
  })
  #END: LEARNER FILTERS - TEXT INPUTS - NOT USED
  
  #START: LEARNER FILTERS - FILTERING - NOT USED
  
  assign("selectedGenderIDs", "", envir = .GlobalEnv)
  assign("selectedAgeIDs", "", envir = .GlobalEnv)
  assign("selectedDegreeIDs", "", envir = .GlobalEnv)
  assign("selectedCountryIDs", "", envir = .GlobalEnv)
  assign("selectedEmplAreaIDs", "", envir = .GlobalEnv)
  assign("selectedEmplStatusIDs", "", envir = .GlobalEnv)
  assign("selectedFoundCourseIDs", "", envir = .GlobalEnv)
  assign("selectedHopeCourseIDs", "", envir = .GlobalEnv)
  assign("selectedSubjectsIDs", "", envir = .GlobalEnv)
  assign("selectedMethodIDs", "", envir = .GlobalEnv)
  assign("selectedPlaceIDs", "", envir = .GlobalEnv)
  assign("selectedExperienceIDs", "", envir = .GlobalEnv)
  
  observeEvent(input$gender, {
    if (exists("fullGenderData")) {
      selected <- input$gender
      data <- subset(fullGenderData, gender == selected)
      learnerIDs <- as.vector(na.omit(data$learner_id))
      currentLearners <- unlist(strsplit(input$filteredLearners, "[,]"))
      if (filtersEnabled == TRUE) {
        currentLearners <- setdiff(currentLearners, selectedGenderIDs)
        assign("selectedGenderIDs", learnerIDs, envir = .GlobalEnv)
        learnerIDs <- append(learnerIDs, currentLearners)  
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }else {
        assign("selectedGenderIDs", learnerIDs, envir = .GlobalEnv)
        assign("filtersEnabled", TRUE, envir = .GlobalEnv)
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }
      
    }
  })
  
  observeEvent(input$age, {
    if (exists("fullAgeData")) {
      selected <- input$age
      data <- subset(fullAgeData, age == selected)
      learnerIDs <- as.vector(na.omit(data$learner_id))
      currentLearners <- unlist(strsplit(input$filteredLearners, "[,]"))
      if (filtersEnabled == TRUE) {
        currentLearners <- setdiff(currentLearners, selectedAgeIDs)
        assign("selectedAgeIDs", learnerIDs, envir = .GlobalEnv)
        learnerIDs <- append(learnerIDs, currentLearners)  
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }else {
        assign("selectedAgeIDs", learnerIDs, envir = .GlobalEnv)
        assign("filtersEnabled", TRUE, envir = .GlobalEnv)
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }
    }
  })
  
  observeEvent(input$selected, {
    if (exists("fullCountryData")) {
      selected <- input$selected
      data <- subset(fullCountryData, country == selected)
      learnerIDs <- as.vector(na.omit(data$learner_id))
      currentLearners <- unlist(strsplit(input$filteredLearners, "[,]"))
      if (filtersEnabled == TRUE) {
        currentLearners <- setdiff(currentLearners, selectedCountryIDs)
        assign("selectedCountryIDs", learnerIDs, envir = .GlobalEnv)
        learnerIDs <- append(learnerIDs, currentLearners)  
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }else {
        assign("selectedCountryIDs", learnerIDs, envir = .GlobalEnv)
        assign("filtersEnabled", TRUE, envir = .GlobalEnv)
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }
    }
  })
  
  observeEvent(input$emplArea, {
    if (exists("fullEmplAreaData")) {
      selected <- input$emplArea
      data <- subset(fullEmplAreaData, employment_area == selected)
      learnerIDs <- as.vector(na.omit(data$learner_id))
      currentLearners <- unlist(strsplit(input$filteredLearners, "[,]"))
      if (filtersEnabled == TRUE) {
        currentLearners <- setdiff(currentLearners, selectedEmplAreaIDs)
        assign("selectedEmplAreaIDs", learnerIDs, envir = .GlobalEnv)
        learnerIDs <- append(learnerIDs, currentLearners)  
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }else {
        assign("selectedEmplAreaIDs", learnerIDs, envir = .GlobalEnv)
        assign("filtersEnabled", TRUE, envir = .GlobalEnv)
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }
    }
  })
  
  observeEvent(input$emplStatus, {
    if (exists("fullEmplStatusData")) {
      selected <- input$emplStatus
      data <- subset(fullEmplStatusData, employment_status == selected)
      learnerIDs <- as.vector(na.omit(data$learner_id))
      currentLearners <- unlist(strsplit(input$filteredLearners, "[,]"))
      if (filtersEnabled == TRUE) {
        currentLearners <- setdiff(currentLearners, selectedEmplStatusIDs)
        assign("selectedEmplStatusIDs", learnerIDs, envir = .GlobalEnv)
        learnerIDs <- append(learnerIDs, currentLearners)  
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }else {
        assign("selectedEmplStatusIDs", learnerIDs, envir = .GlobalEnv)
        assign("filtersEnabled", TRUE, envir = .GlobalEnv)
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }
    }
  })
  
  observeEvent(input$degree, {
    if (exists("fullDegreeData")) {
      selected <- input$degree
      data <- subset(fullDegreeData, degree == selected)
      learnerIDs <- as.vector(na.omit(data$learner_id))
      currentLearners <- unlist(strsplit(input$filteredLearners, "[,]"))
      if (filtersEnabled == TRUE) {
        currentLearners <- setdiff(currentLearners, selectedDegreeIDs)
        assign("selectedDegreeIDs", learnerIDs, envir = .GlobalEnv)
        learnerIDs <- append(learnerIDs, currentLearners)  
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }else {
        assign("selectedDegreeIDs", learnerIDs, envir = .GlobalEnv)
        assign("filtersEnabled", TRUE, envir = .GlobalEnv)
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }
    }
  })
  
  observeEvent(input$foundCourse, {
    if (exists("fullFoundCourseData")) {
      selected <- input$foundCourse
      data <- subset(fullFoundCourseData, how_found_course == selected)
      learnerIDs <- as.vector(na.omit(data$learner_id))
      currentLearners <- unlist(strsplit(input$filteredLearners, "[,]"))
      if (filtersEnabled == TRUE) {
        currentLearners <- setdiff(currentLearners, selectedFoundCourseIDs)
        assign("selectedFoundCourseIDs", learnerIDs, envir = .GlobalEnv)
        learnerIDs <- append(learnerIDs, currentLearners)  
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }else {
        assign("selectedFoundCourseIDs", learnerIDs, envir = .GlobalEnv)
        assign("filtersEnabled", TRUE, envir = .GlobalEnv)
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }
    }
  })
  
  observeEvent(input$hopeCourse, {
    if (exists("fullHopeCourseData")) {
      selected <- input$hopeCourse
      data <- subset(fullHopeCourseData, hope_get_course == selected)
      learnerIDs <- as.vector(na.omit(data$learner_id))
      currentLearners <- unlist(strsplit(input$filteredLearners, "[,]"))
      if (filtersEnabled == TRUE) {
        currentLearners <- setdiff(currentLearners, selectedHopeCourseIDs)
        assign("selectedHopeCourseIDs", learnerIDs, envir = .GlobalEnv)
        learnerIDs <- append(learnerIDs, currentLearners)  
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }else {
        assign("selectedHopeCourseIDs", learnerIDs, envir = .GlobalEnv)
        assign("filtersEnabled", TRUE, envir = .GlobalEnv)
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }
    }
  })
  
  observeEvent(input$experience, {
    if (exists("fullExperienceData")) {
      selected <- input$experience
      data <- subset(fullExperienceData, previous_online_course == selected)
      learnerIDs <- as.vector(na.omit(data$learner_id))
      currentLearners <- unlist(strsplit(input$filteredLearners, "[,]"))
      if (filtersEnabled == TRUE) {
        currentLearners <- setdiff(currentLearners, selectedExperienceIDs)
        assign("selectedExperienceIDs", learnerIDs, envir = .GlobalEnv)
        learnerIDs <- append(learnerIDs, currentLearners)  
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }else {
        assign("selectedExperienceIDs", learnerIDs, envir = .GlobalEnv)
        assign("filtersEnabled", TRUE, envir = .GlobalEnv)
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }
    }
  })
  
  observeEvent(input$subjects, {
    if (exists("fullSubjectsData")) {
      selected <- input$subjects
      data <- subset(fullSubjectsData, subject == selected)
      learnerIDs <- as.vector(na.omit(data$learner_id))
      currentLearners <- unlist(strsplit(input$filteredLearners, "[,]"))
      if (filtersEnabled == TRUE) {
        currentLearners <- setdiff(currentLearners, selectedSubjectsIDs)
        assign("selectedSubjectsIDs", learnerIDs, envir = .GlobalEnv)
        learnerIDs <- append(learnerIDs, currentLearners)  
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }else {
        assign("selectedSubjectsIDs", learnerIDs, envir = .GlobalEnv)
        assign("filtersEnabled", TRUE, envir = .GlobalEnv)
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }
    }
  })
  
  observeEvent(input$methods, {
    if (exists("fullMethodsData")) {
      selected <- input$methods
      split <- strsplit(selected, "[;]") 
      method <- split[0]
      degree <- split[1]
      data <- subset(fullMethodsData, learning_method == method)
      data <- subset(fullMethodsData, degree == degree)
      learnerIDs <- as.vector(na.omit(data$learner_id))
      currentLearners <- unlist(strsplit(input$filteredLearners, "[,]"))
      if (filtersEnabled == TRUE) {
        currentLearners <- setdiff(currentLearners, selectedMethodIDs)
        assign("selectedMethodIDs", learnerIDs, envir = .GlobalEnv)
        learnerIDs <- append(learnerIDs, currentLearners)  
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }else {
        assign("selectedMethodIDs", learnerIDs, envir = .GlobalEnv)
        assign("filtersEnabled", TRUE, envir = .GlobalEnv)
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }
    }
  })
  
  observeEvent(input$place, {
    if (exists("fullPlaceData")) {
      selected <- input$place
      data <- subset(fullPlaceData, learning_place == selected)
      learnerIDs <- as.vector(na.omit(data$learner_id))
      currentLearners <- unlist(strsplit(input$filteredLearners, "[,]"))
      if (filtersEnabled == TRUE) {
        currentLearners <- setdiff(currentLearners, selectedPlaceIDs)
        assign("selectedPlaceIDs", learnerIDs, envir = .GlobalEnv)
        learnerIDs <- append(learnerIDs, currentLearners)  
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }else {
        assign("selectedPlaceIDs", learnerIDs, envir = .GlobalEnv)
        assign("filtersEnabled", TRUE, envir = .GlobalEnv)
        updateTextInput(session, "filteredLearners", value = learnerIDs)
      }
    }
  })
  
  observeEvent(input$resetFilters, {
    updateTextInput(session, "gender", value = "")
    updateTextInput(session, "age", value = "")
    updateTextInput(session, "degree", value = "")
    updateTextInput(session, "emplArea", value = "")
    updateTextInput(session, "emplStatus", value = "")
    updateTextInput(session, "foundCourse", value = "")
    updateTextInput(session, "hopeCourse", value = "")
    updateTextInput(session, "experience", value = "")
    updateTextInput(session, "subjects", value = "")
    updateTextInput(session, "methods", value = "")
    updateTextInput(session, "place", value = "")
    updateTextInput(session, "selected", value = "")
    updateTextInput(session, "filteredLearners", value = allLearners)
    assign("filtersEnabled", FALSE, envir = .GlobalEnv)
  })
  
  observeEvent(input$learnerStreamSelect, {
    if (exists("streamData")) {
      selected <- input$learnerStreamSelect
      data <- subset(streamData, set == selected)
      learnerIDs <- as.vector(na.omit(streamData$learner_id))
      updateTextInput(session, "filteredStreams", value = learnerIDs)
    }
  })
  
  
  
  
  output$howFoundCourse <- renderChart2({
    chartDependency()
    # Check whether the survey for the selected course had this question
    validate(
      need(checkHasHowFoundCourse(pre_course_data) == TRUE,
           "The survey for this course doesn't have this question")
    )
    data <- getLearnersByHowFoundCourse(pre_course_data)
    assign("fullHowFoundCourseData", data[[1]], envir = .GlobalEnv)
    
    plotData <- data[[2]]
    catList <- plotData$how_found_course
    plotData$foundCourseFilter <- plotData$how_found_course
    plotData$how_found_course <- seq(from = 0, to = nrow(plotData) - 1)
    colnames(plotData)[c(1,2)] <- c("x", "y")
    histogram <- Highcharts$new()
    histogram$chart (width = 380)
    histogram$series(
      data = toJSONArray2(plotData, json = FALSE, names = TRUE),
      type = "bar",
      name = "learners"
    )
    histogram$xAxis (
      categories = plotData$catList,
      labels = list(
        style = list(
          fontSize = 8
        )
      )
    )
    histogram$plotOptions(
      bar = list(
        cursor = "pointer", 
        point = list(
          events = list(
            click = "#! function() { Shiny.onInputChange('click', {foundCourseFilter: this.foundCourseFilter})} !#"
          )
        )
      )
    )
    return (histogram)
  })
  
  
  output$hopeGetFromCourse <- renderChart2({
    chartDependency()
    
    data <- getLearnersByHopeGetFromCourse(pre_course_data)
    assign("fullHopeCourseData", data[[1]], envir = .GlobalEnv)
    plotData <- data[[2]]
    catList <- plotData$hope_get_course
    plotData$hopeCourseFilter <- plotData$hope_get_course
    plotData$hope_get_course <- seq(from = 0, to = nrow(plotData) - 1)
    colnames(plotData)[c(1,2)] <- c("x", "y")
    histogram <- Highcharts$new()
    histogram$chart (width = 380)
    histogram$series(
      data = toJSONArray2(plotData, json = FALSE, names = TRUE),
      type = "bar",
      name = "learners"
    )
    histogram$xAxis (
      categories = catList,
      labels = list(
        style = list(
          fontSize = 8
        )
      )
    )
    histogram$plotOptions(
      bar = list(
        cursor = "pointer", 
        point = list(
          events = list(
            click = "#! function() { Shiny.onInputChange('click', {hopeCourseFilter: this.hopeCourseFilter})} !#"
          )
        )
      )
    )
    return (histogram)
  })
  
  output$learningMethods <- renderChart2({
    chartDependency()
    
    data <- getLearnersByLearningMethods(pre_course_data)
    assign("fullMethodsData", data[[1]], envir = .GlobalEnv)
    plotData <- data[[2]]
    histogram <- Highcharts$new()
    histogram$chart (width = 380)
    
    histogram$series(
      data = list(
        list(x = 0, y = plotData[5,3], methodsFilter = paste(plotData[5,1], plotData[5,2], sep = ";")),
        list(x = 1, y = plotData[11,3], methodsFilter = paste(plotData[11,1], plotData[11,2], sep = ";")),
        list(x = 2, y = plotData[17,3], methodsFilter = paste(plotData[17,1], plotData[17,2], sep = ";")),
        list(x = 3, y = plotData[23,3], methodsFilter = paste(plotData[23,1], plotData[23,2], sep = ";")),
        list(x = 4, y = plotData[29,3], methodsFilter = paste(plotData[29,1], plotData[29,2], sep = ";"))
      ), 
      type = "column",
      name = "Strongly dislike"
    )
    histogram$series(
      data = list(
        list(x = 0, y = plotData[1,3], methodsFilter = paste(plotData[1,1], plotData[1,2], sep = ";")),
        list(x = 1, y = plotData[7,3], methodsFilter = paste(plotData[7,1], plotData[7,2], sep = ";")),
        list(x = 2, y = plotData[13,3], methodsFilter = paste(plotData[13,1], plotData[13,2], sep = ";")),
        list(x = 3, y = plotData[19,3], methodsFilter = paste(plotData[19,1], plotData[19,2], sep = ";")),
        list(x = 4, y = plotData[25,3], methodsFilter = paste(plotData[25,1], plotData[25,2], sep = ";"))
      ), 
      type = "column",
      name = "Dislike"
    )
    histogram$series(
      data = list(
        list(x = 0, y = plotData[4,3], methodsFilter = paste(plotData[4,1], plotData[4,2], sep = ";")),
        list(x = 1, y = plotData[10,3], methodsFilter = paste(plotData[10,1], plotData[10,2], sep = ";")),
        list(x = 2, y = plotData[16,3], methodsFilter = paste(plotData[16,1], plotData[16,2], sep = ";")),
        list(x = 3, y = plotData[22,3], methodsFilter = paste(plotData[22,1], plotData[22,2], sep = ";")),
        list(x = 4, y = plotData[28,3], methodsFilter = paste(plotData[28,1], plotData[28,2], sep = ";"))
      ), 
      type = "column",
      name = "Neutral"
    )
    histogram$series(
      data = list(
        list(x = 0, y = plotData[3,3], methodsFilter = paste(plotData[3,1], plotData[3,2], sep = ";")),
        list(x = 1, y = plotData[9,3], methodsFilter = paste(plotData[9,1], plotData[9,2], sep = ";")),
        list(x = 2, y = plotData[15,3], methodsFilter = paste(plotData[15,1], plotData[15,2], sep = ";")),
        list(x = 3, y = plotData[21,3], methodsFilter = paste(plotData[21,1], plotData[21,2], sep = ";")),
        list(x = 4, y = plotData[27,3], methodsFilter = paste(plotData[27,1], plotData[27,2], sep = ";"))
      ), 
      type = "column",
      name = "Like"
    )
    histogram$series(
      data = list(
        list(x = 0, y = plotData[6,3], methodsFilter = paste(plotData[6,1], plotData[6,2], sep = ";")),
        list(x = 1, y = plotData[12,3], methodsFilter = paste(plotData[12,1], plotData[12,2], sep = ";")),
        list(x = 2, y = plotData[18,3], methodsFilter = paste(plotData[18,1], plotData[18,2], sep = ";")),
        list(x = 3, y = plotData[24,3], methodsFilter = paste(plotData[24,1], plotData[24,2], sep = ";")),
        list(x = 4, y = plotData[30,3], methodsFilter = paste(plotData[30,1], plotData[30,2], sep = ";"))
      ), 
      type = "column",
      name = "Strongly like"
    )
    histogram$series(
      data = list(
        list(x = 0, y = plotData[2,3], methodsFilter = paste(plotData[2,1], plotData[2,2], sep = ";")),
        list(x = 1, y = plotData[8,3], methodsFilter = paste(plotData[8,1], plotData[8,2], sep = ";")),
        list(x = 2, y = plotData[14,3], methodsFilter = paste(plotData[14,1], plotData[14,2], sep = ";")),
        list(x = 3, y = plotData[20,3], methodsFilter = paste(plotData[20,1], plotData[20,2], sep = ";")),
        list(x = 4, y = plotData[26,3], methodsFilter = paste(plotData[26,1], plotData[26,2], sep = ";"))
      ), 
      type = "column",
      name = "Don't know"
    )
    histogram$xAxis (
      categories = unique(plotData$learning_method),
      labels = list(
        style = list(
          fontSize = 8
        )
      )
    )
    histogram$plotOptions(
      column = list(
        cursor = "pointer", 
        point = list(
          events = list(
            click = "#! function() { Shiny.onInputChange('click', {methodsFilter: this.methodsFilter})} !#"
          )
        )
      )
    )
    return (histogram)
  })
  
  output$interestedSubjects <- renderChart2({
    chartDependency()
    
    data <- getLearnersByInterestedSubjects(pre_course_data)
    assign("fullSubjectsData", data[[1]], envir = .GlobalEnv)
    plotData <- data[[2]]
    catList <- plotData$subject
    plotData$subjectsFilter <- plotData$subject
    plotData$subject <- seq(from = 0, to = nrow(plotData) - 1)
    colnames(plotData)[c(1,2)] <- c("x", "y")
    histogram <- Highcharts$new()
    histogram$chart (width = 380)
    
    histogram$series(
      data = toJSONArray2(plotData, F, T),
      type = "column",
      name = "learners"
    )
    histogram$xAxis (
      categories = catList,
      labels = list(
        style = list(
          fontSize = 8
        )
      )
    )
    histogram$plotOptions(
      column = list(
        cursor = "pointer", 
        point = list(
          events = list(
            click = "#! function() { Shiny.onInputChange('click', {subjectsFilter: this.subjectsFilter})} !#"
          )
        )
      )
    )
    return (histogram)
  })
  
  output$pastExperience <- renderChart2({
    chartDependency()
    
    data <- getLearnersByPastOnlineCourse(pre_course_data)
    assign("fullExperienceData", data[[1]], envir = .GlobalEnv)
    plotData <- data[[2]]
    catList <- plotData$previous_online_course
    plotData$experienceFilter <- plotData$previous_online_course
    plotData$previous_online_course <- seq(from = 0, to = nrow(plotData) - 1)
    colnames(plotData)[c(1,2)] <- c("x", "y")
    histogram <- Highcharts$new()
    histogram$chart (width = 380)
    histogram$series(
      data = toJSONArray2(plotData, F, T),
      type = "column",
      name = "learners"
    )
    histogram$xAxis (
      categories = catList,
      labels = list(
        style = list(
          fontSize = 8
        )
      )
    )
    histogram$plotOptions(
      column = list(
        cursor = "pointer", 
        point = list(
          events = list(
            click = "#! function() { Shiny.onInputChange('click', {experienceFilter: this.experienceFilter})} !#"
          )
        )
      )
    )
    return (histogram)
  })
  
  output$learningPlace <- renderChart2({
    chartDependency()
    
    data <- getLearnersByExpectedLearningPlace(pre_course_data)
    assign("fullPlaceData", data[[1]], envir = .GlobalEnv)
    plotData <- data[[2]]
    catList <- plotData$learning_place
    plotData$placeFilter <- plotData$learning_place
    plotData$learning_place <- seq(from = 0, to = nrow(plotData) - 1)
    colnames(plotData)[c(1,2)] <- c("x", "y")
    histogram <- Highcharts$new()
    histogram$chart (width = 380)
    histogram$series(
      data = toJSONArray2(plotData, F, T),
      type = "column",
      name = "learners"
    )
    histogram$xAxis (
      categories = catList,
      labels = list(
        style = list(
          fontSize = 8
        )
      )
    )
    histogram$plotOptions(
      column = list(
        cursor = "pointer", 
        point = list(
          events = list(
            click = "#! function() { Shiny.onInputChange('click', {placeFilter: this.placeFilter})} !#"
          )
        )
      )
    )
    return (histogram)
  })
  # END: LEARNER FITLERS - CHARTS - NOT USED
  # =============================================END NOT USED==============================================
  
  
  # START OF ENROLMENTS TABLE GRAPHS - Demographics tab
  
  # Produces graph of the values of learners age groups
  # Depending of the selected radio button it shows either percentages or numbers
  output$learnersAgeBar <- renderChart2({
    
    #used to update the chart when the Go button is pressed
    chartDependency()
    
    #a data frame of age data - either with percentages or values depending on the radio button selected
    data <- learnersAgeData(input$rbChartDataType)
    
    #creating the learner age chart
    a <- rCharts:::Highcharts$new()
    a$chart(type = "column", width = 750)
    
    #x-axis with the age groups
    a$xAxis(categories = data$levels)
    
    #y-axis with either percentages or values 
    if(input$rbChartDataType == "percentages"){
      a$yAxis(title = list(text = "Percentage of Population"))
    } else {
      a$yAxis(title = list(text = "Population"))
    }
    
    #contains the data for all the selected course runs
    a$data(data[c(names(enrolment_data))])
    a$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
    a$plotOptions(
      column = list(
        dataLabels = list(
          enabled = "true"
        ),
        animation = FALSE
      )
    )
    return(a)
  })
  
  #download button for the learner age data - as a csv file
  output$downloadLearnerAge <- downloadHandler(
    filename = function() { paste("learner_age", '.csv', sep='') },
    content = function(file) {
      data <- learnersAgeData(input$rbChartDataType)
      write.csv(data, file)
    }
  )
  
  # Produces graph of the values of learners gender groups
  # Depending of the selected radio button it shows either percentages or numbers
  output$learnersGender <- renderChart2({
    
    #used to update the chart when the Go button is pressed
    chartDependency()
    
    #a data frame of gender data - either with percentages or value depending on the radio button selected
    data <- learnersGenderData(input$rbChartDataType)
    
    #creating the gender chart
    a <- rCharts:::Highcharts$new()
    a$chart(type = "column", width = 400)
    
    #x-axis with the gender values
    a$xAxis(categories = data$levels)
    
    #y-axis with either percentages or values 
    if(input$rbChartDataType == "percentages"){
      a$yAxis(title = list(text = "Percentage of Population"))
    } else {
      a$yAxis(title = list(text = "Population"))
    }
    
    #contains the data for all the selected course runs
    a$data(data[c(names(enrolment_data))])
    a$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
    a$plotOptions(
      column = list(
        dataLabels = list(
          enabled = "true"
        ),
        animation = FALSE
      )
    )
    return(a)
  })
  
  #download button for the gender data - as a csv file
  output$downloadLearnerGender <- downloadHandler(
    filename = function() { paste("learner_gender", '.csv', sep='') },
    content = function(file) {
      data <- learnersGenderData(input$rbChartDataType)
      write.csv(data, file)
    }
  )
  
  # Produces graph of the values of the learners employment area
  # Depending of the selected radio button it shows either percentages or numbers
  output$employmentBar <-renderChart2({
    
    #to update the chart when the Go button is pressed
    chartDependency()
    
    #data frame with employment area count/percentages for each course run
    data <- learnersEmploymentData(input$rbChartDataType)
    
    #creating the bar chart
    a <- rCharts:::Highcharts$new()
    a$chart(type = "bar", width = 1200, height = 650)
    
    #contains the data for all selected course runs
    a$data(data[c(names(enrolment_data))])
    a$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
    
    #x axis contains the employment area 
    a$xAxis(categories = gsub( "_"," ",(data$area)))
    
    #y-axis with either percentages or values
    if(input$rbChartDataType == "percentages"){
      a$yAxis(title = list(text = "Percentage of Population"))
    } else {
      a$yAxis(title = list(text = "Population"))
    }
    a$plotOptions(
      bar = list(
        dataLabels = list(
          enabled = "true"
        ),
        animation = FALSE
      )
    )
    return(a)
  })
  
  #download button for employment area data - as a csv
  output$downloadLearnerEmployment <- downloadHandler(
    filename = function() { paste("learner_employment", '.csv', sep='') },
    content = function(file) {
      data <- learnersEmploymentData(input$rbChartDataType)
      write.csv(data, file)
    }
  )	
  
  # Produces graph of the values of the learners employment status
  # Depending of the selected radio button it shows either percentages or numbers
  output$employmentStatus <- renderChart2({
    
    #to update the chart when the Go button is pressed
    chartDependency()
    
    #data frame with status count/percentages for each course run
    data<-learnersStatusData(input$rbChartDataType)
    
    #creating the bar chart
    a <- rCharts:::Highcharts$new()
    a$chart(type = "bar", width = 1200, height = 650)
    
    #contains the data for all selected course runs
    a$data(data[c(names(enrolment_data))])
    a$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
    
    #x-axis contains the status options
    a$xAxis(categories = gsub( "_"," ",unlist(data$levels)))
    
    #y-axis with either percentages or values
    if(input$rbChartDataType == "percentages"){
      a$yAxis(title = list(text = "Percentage of Population"))
    } else {
      a$yAxis(title = list(text = "Population"))
    }
    a$plotOptions(
      bar = list(
        dataLabels = list(
          enabled = "true"
        ),
        animation = FALSE
      )
    )
    return(a)
  })
  
  #download button for status data - as a csv
  output$downloadLearnerStatus <- downloadHandler(
    filename = function() { paste("learner_status", '.csv', sep='') },
    content = function(file) {
      data <- learnersStatusData(input$rbChartDataType)
      write.csv(data, file)
    }
  )	
  
  # Produces graph of the values of the learners education level
  # Depending of the selected radio button it shows either percentages or numbers
  output$degreeLevel <- renderChart2({
    
    #to update the chart when the go button is pressed
    chartDependency()
    
    #data frame with education status count/percentage for each selected course run
    data<-learnersEducationData(input$rbChartDataType)
    
    #creating the chart
    a <- rCharts:::Highcharts$new()
    a$chart(type = "column", width = 1200, height = 650)
    
    #contains the data for all selected course runs
    a$data(data[c(names(enrolment_data))])
    a$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
    
    #x-axis containing the education status options
    a$xAxis(categories = gsub( "_"," ",data$level))
    
    #y-axis with either percentages or values
    if(input$rbChartDataType == "percentages"){
      a$yAxis(title = list(text = "Percentage of Population"))
    } else {
      a$yAxis(title = list(text = "Population"))
    }
    a$plotOptions(
      column = list(
        dataLabels = list(
          enabled = "true"
        ),
        animation = FALSE
      )
    )
    return(a)
  })
  
  
  #download button for education status data - as a csv
  output$downloadLearnerEducation <- downloadHandler(
    filename = function() { paste("learner_education", '.csv', sep='') },
    content = function(file) {
      data <- learnersEducationData(input$rbChartDataType)
      write.csv(data, file)
    }
  )	
  
  # Produces map of which countries the learners are from and in what numbers
  output$learnerMap <- renderGvis({
    chartDependency()
    
    data <- getLearnersByCountry(pre_course_data[which(pre_course_data$country != "Unknown"), ])
    assign("fullCountryData", data[[1]], envir = .GlobalEnv)
    plotData <- data[[2]]
    jscode <- "var sel = chart.getSelection();  
								var row = sel[0].row;
								var country = data.getValue(row, 0);
								$('input#selected').val(country);
								$('input#selected').trigger('change');"
    
    
    map <- gvisGeoChart(plotData, locationvar = "country", colorvar = "learners",
                        options = list(
                          gvis.listener.jscode = jscode,
                          width = 1100,
                          height = 600,
                          keepAspectRatio = "false",
                          colorAxis = "{colors:['#91BFDB', '#FC8D59']}"
                        )
    )
    return (map)
  })
  
  output$downloadCountryData <- downloadHandler(	
    filename = function() { paste("learner_country", '.csv', sep='') },
    content = function(file) {
      data <- getLearnersByCountry(pre_course_data[which(pre_course_data$country != "Unknown"), ])[[2]]		
      write.csv(data, file)
    }
  )	
  
  #Produces map of which HDI level the learners are from based on their country data
  output$HDIColumn <- renderChart2({
    chartDependency()
    data <- learnersHDIData()
    
    chart <- Highcharts$new()
    chart$chart(type = 'column', width = 1200)
    chart$data(data[c(names(enrolment_data))])
    chart$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
    chart$xAxis(categories = data$levels)
    chart$yAxis(title = list(text = "Percentage of Countries"))
    chart$plotOptions(
      column = list(
        dataLabels = list(
          enabled = "true"
        ),
        animation = FALSE
      )
    )
    return(chart)
  })
  
  output$downloadHDIData <- downloadHandler(	
    filename = function() { paste("learner_HDI", '.csv', sep='') },
    content = function(file) {
      data <- learnersHDIData()
      write.csv(data, file)
    }
  )
  # END DEMOGRAPHICS TAB
  
  
  
  # START STATEMENT DEMOGRAPHICS TAB
  
  # Column chart of statement purchaser's genders
  # Depending of the selected radio button it shows either percentages or numbers
  output$stateGenderColumn <- renderChart2({
    
    #to update the chart when the Go button is pressed
    chartDependency()
    
    #data frame with gender count/percentage for each selected course run
    data <- stateGenderData(input$rbChartDataType)
    
    #creating the column chart
    a <- rCharts:::Highcharts$new()
    a$chart(type = "column", width = 400)
    
    #x-axis contains the gender levels
    a$xAxis(categories = data$levels)
    
    #y-axis with either percentages or values
    if(input$rbChartDataType == "percentages"){
      a$yAxis(title = list(text = "Percentage of Population"))
    } else {
      a$yAxis(title = list(text = "Population"))
    }
    
    #data for each of the selected course runs
    a$data(data[c(names(enrolment_data))])
    a$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
    a$plotOptions(
      column = list(
        dataLabels = list(
          enabled = "true"
        ),
        animation = FALSE
      )
    )
    return(a)
  })
  
  #button to download the statement purchasers' gender data as a csv file
  output$downloadStateLearnerGender <- downloadHandler(
    filename = function() { paste("statements_learner_gender", '.csv', sep='') },
    content = function(file) {
      data <- stateGenderData(input$rbChartDataType)
      write.csv(data, file)
    }
  )
  
  # Column chart of statement purchaser's age groups
  # Depending of the selected radio button it shows either percentages or numbers
  output$stateAgeColumn <- renderChart2({
    
    #to update the chart when pressing the Go button
    chartDependency()
    
    # data frame with age group values/percentage for each course run
    data<-stateAgeData(input$rbChartDataType)
    
    #creating the column chart
    a <- rCharts:::Highcharts$new()
    a$chart(type = "column", width = 750)
    
    #x-axis contains the age group levels
    a$xAxis(categories = data$levels)
    
    #y-axis with either percentages or values
    if(input$rbChartDataType == "percentages"){
      a$yAxis(title = list(text = "Percentage of Population"))
    } else {
      a$yAxis(title = list(text = "Population"))
    }
    
    #data about all the selected course runs
    a$data(data[c(names(enrolment_data))])
    
    a$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
    a$plotOptions(
      column = list(
        dataLabels = list(
          enabled = "true"
        ),
        animation = FALSE
      )
    )
    return(a)
  })
  
  #button to download the statement purchasers' age data as a csv file
  output$downloadStateLearnerAge <- downloadHandler(
    filename = function() { paste("statements_learner_age", '.csv', sep='') },
    content = function(file) {
      data <- stateAgeData(input$rbChartDataType)
      write.csv(data, file)
    }
  )
  
  # Bar chart of statement purchasers' employment area
  # Depending of the selected radio button it shows either percentages or numbers
  output$stateEmploymentAreaBar <- renderChart2({
    
    #to update the chart when the Go button is pressed
    chartDependency()
    
    #data frame with employment area values/percentages for each course run
    data <- stateEmploymentData(input$rbChartDataType)
    
    #creating the chart
    a <- rCharts:::Highcharts$new()
    a$chart(type = "bar", width = 1200, height = 650)
    
    #data for all the course runs selected
    a$data(data[c(names(enrolment_data))])
    a$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
    
    #x-axis to with the employment area options
    a$xAxis(categories = gsub( "_"," ",(data$area)))
    
    #y-axis with either percentages or values
    if(input$rbChartDataType == "percentages"){
      a$yAxis(title = list(text = "Percentage of Population"))
    } else {
      a$yAxis(title = list(text = "Population"))
    }
    a$plotOptions(
      bar = list(
        dataLabels = list(
          enabled = "true"
        ),
        animation = FALSE
      )
    )
    return(a)
  })
  
  #button for downloading the statement purchsers' employment area data in csv
  output$downloadStateLearnerEmployment <- downloadHandler(
    filename = function() { paste("statements_learner_employment", '.csv', sep='') },
    content = function(file) {
      data <- stateEmploymentData(input$rbChartDataType)
      write.csv(data, file)
    }
  )
  
  # Column chart of statement purchasers' employment status
  # Depending of the selected radio button it shows either percentages or numbers
  output$stateEmploymentStatusColumn <- renderChart2({
    
    #creates the chart when pressing the Go button
    chartDependency()
    
    #data frame with status groups value/percentage for each course run
    data<-stateStatusData(input$rbChartDataType)
    
    #creating the chart
    a <- rCharts:::Highcharts$new()
    a$chart(type = "bar", width = 1200, height = 650)
    
    #chart data for all the selected course runs
    a$data(data[c(names(enrolment_data))])
    a$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
    
    #x-axis contains the employment status levels
    a$xAxis(categories = gsub( "_"," ",unlist(data$levels)))
    
    #y-axis with either percentages or values
    if(input$rbChartDataType == "percentages"){
      a$yAxis(title = list(text = "Percentage of Population"))
    } else {
      a$yAxis(title = list(text = "Population"))
    }
    
    a$plotOptions(
      bar = list(
        dataLabels = list(
          enabled = "true"
        ),
        animation = FALSE
      )
    )
    return(a)
  })
  
  #button for downloading status data for statement purchasers as csv file
  output$downloadStateLearnerStatus <- downloadHandler(
    filename = function() { paste("statements_learner_status", '.csv', sep='') },
    content = function(file) {
      data <- stateStatusData(input$rbChartDataType)
      write.csv(data, file)
    }
  )
  
  # Column chart of statement purchaser's education level
  # Depending of the selected radio button it shows either percentages or numbers
  output$stateDegreeColumn <- renderChart2({
    
    #to update the chart after pressing the Go button
    chartDependency()
    
    #data frame with education status value/percentage for each course run selected
    data<-stateEducationData(input$rbChartDataType)
    
    #creating the chart
    a <- rCharts:::Highcharts$new()
    a$chart(type = "column", width = 1200, height = 650)
    
    #chart data for all the selected course runs
    a$data(data[c(names(enrolment_data))])
    a$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
    
    #x-axis with the education status categories
    a$xAxis(categories = gsub( "_"," ",data$level))
    
    #y-axis with either percentages or values
    if(input$rbChartDataType == "percentages"){
      a$yAxis(title = list(text = "Percentage of Population"))
    } else {
      a$yAxis(title = list(text = "Population"))
    }
    
    a$plotOptions(
      column = list(
        dataLabels = list(
          enabled = "true"
        ),
        animation = FALSE
      )
    )
    return(a)
  })
  
  #button for downloading education status data for all the statement purchasers
  output$downloadStateLearnerEducation <- downloadHandler(
    filename = function() { paste("statements_learner_education", '.csv', sep='') },
    content = function(file) {
      data <- stateEducationData(input$rbChartDataType)
      write.csv(data, file)
    }
  )
  
  # Map of what countries the statement purchaser's came from
  output$stateLearnerMap <- renderGvis({		
    data <- getLearnersByCountry(pre_course_data[which(pre_course_data$country != "Unknown" & pre_course_data$purchased_statement_at != ""), ])
    assign("fullCountryData", data[[1]], envir = .GlobalEnv)
    plotData <- data[[2]]
    jscode <- "var sel = chart.getSelection();  
    var row = sel[0].row;
    var country = data.getValue(row, 0);
    $('input#selected').val(country);
    $('input#selected').trigger('change');"
    
    map <- gvisGeoChart(plotData, locationvar = "country", colorvar = "learners",
                        options = list(
                          gvis.listener.jscode = jscode,
                          width = 1100,
                          height = 600,
                          keepAspectRatio = "false",
                          colorAxis = "{colors:['#91BFDB', '#FC8D59']}"
                        )
    )
    return (map)
  })
  
  output$downloadStateLearnerCountry <- downloadHandler(
    filename = function() { paste("statements_learner_country", '.csv', sep='') },
    content = function(file) {
      data <- getLearnersByCountry(pre_course_data[which(pre_course_data$country != "Unknown" & pre_course_data$purchased_statement_at != ""), ])
      write.csv(data, file)
    }
  )
  
  # Column graph for the HDI levels of statement purchaser's
  output$stateHDIColumn <- renderChart2({
    chartDependency()
    data<-stateHDIData()
    chart <- Highcharts$new()
    chart$chart(type = 'column', width = 1200)
    chart$data(data[c(names(enrolment_data))])
    chart$colors('#7cb5ec', '#434348','#8085e9')
    chart$xAxis(categories = data$levels)
    chart$yAxis(title = list(text = "Percentage of Population"))
    chart$plotOptions(
      column = list(
        dataLabels = list(
          enabled = "true"
        )
      )
    )
    return(chart)
  })
  
  output$downloadStateLearnerHDI <- downloadHandler(
    filename = function() { paste("statements_learner_hdi", '.csv', sep='') },
    content = function(file) {
      data <- stateHDIData()
      write.csv(data, file)
    }
  )
  
  # END STATEMENT DEMOGRAPHICS TAB
  
  
  # START SIGN UPS AND STATEMENTS SOLD TAB
  
  # Line showing sign ups over time
  output$signUpsLine <- renderChart2({
    chartDependency()
    
    analysis <- signUpData()
    data<- analysis[[1]]
    startDays <- analysis[[2]]
    startDay <- analysis[[3]]
    chart <- Highcharts$new()
    chart$chart(type = "line", width = 1200)
    chart$data(data[c(names(enrolment_data))])
    chart$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
    if(length(startDays) == 1){
      chart$xAxis(
        title = list(text = "Day"),
        categories = data$day, plotLines = list(
          list(
            value = startDays[1],
            color = "#7cb5ec",
            width = 3,
            zIndex = 4,
            label = list(
              text = paste("Course Started: ", startDay,
                           sep = " "),
              style = list( color = 'black')
            )
          )
        )
      )
    } else if (length(startDays) == 2){
      chart$xAxis(
        title = list(text = "Day"),
        categories = data$day, plotLines = list(
          list(
            value = startDays[1],
            color = "#7cb5ec",
            width = 3,
            zIndex = 4,
            label = list(
              text = paste(names(enrolment_data)[1],
                           "Start", sep = " "),
              style = list( color = 'black')
            )
          ),
          list(
            value = startDays[2],
            color = "#434348",
            width = 3,
            zIndex = 4,
            label = list(
              text = paste(names(enrolment_data)[2],
                           "Start", sep = " "),
              style = list( color = 'black')
            )
          )
        )
      )
    }else if (length(startDays) == 3){
      chart$xAxis(
        title = list(text = "Day"),
        categories = data$day, plotLines = list(list(
          value = startDays[1],
          color = "#7cb5ec",
          width = 3,
          zIndex = 4,
          label = list(text = paste(names(enrolment_data)[1],"Start", sep = " "),
                       style = list( color = 'black')
          )),
          list(
            value = startDays[2],
            color = '#434348',
            width = 3,
            zIndex = 4,
            label = list(text = paste(names(enrolment_data)[2],"Start", sep = " "),
                         style = list( color = 'black')
            )),
          list(
            value = startDays[3],
            color = '#8085e9',
            width = 3,
            zIndex = 4,
            label = list(text = paste(names(enrolment_data)[3],"Start", sep = " "),
                         style = list( color = 'black')
            ))
        ))
    }else if (length(startDays) == 4){
      chart$xAxis(
        title = list(text = "Day"),
        categories = data$day, plotLines = list(list(
          value = startDays[1],
          color = "#7cb5ec",
          width = 3,
          zIndex = 4,
          label = list(text = paste(names(enrolment_data)[1],"Start", sep = " "),
                       style = list( color = 'black')
          )),
          list(
            value = startDays[2],
            color = '#434348',
            width = 3,
            zIndex = 4,
            label = list(text = paste(names(enrolment_data)[2],"Start", sep = " "),
                         style = list( color = 'black')
            )),
          list(
            value = startDays[3],
            color = '#8085e9',
            width = 3,
            zIndex = 4,
            label = list(text = paste(names(enrolment_data)[3],"Start", sep = " "),
                         style = list( color = 'black')
            )),
          list(
            value = startDays[4],
            color = '#00ffcc',
            width = 3,
            zIndex = 4,
            label = list(text = paste(names(enrolment_data)[4],"Start", sep = " "),
                         style = list( color = 'black')
            ))
        ))
    }
    chart$yAxis(title = list(text = "Frequency"))
    return(chart)
  })
  
  output$downloadSignUps <- downloadHandler(
    filename = function() { paste("signUps", '.csv', sep='') },
    content = function(file) {
      data <- signUpData()[[1]]
      write.csv(data, file)
    }
  )
  
  # Line showing statements sold over time: day vs frequency
  output$statementsSoldLine <- renderChart2({
    
    #to update the chart after pressing the Go button
    chartDependency()
    
    #getting the data for the chart  
    data<-statementsSoldData()
    
    #if the data is not empty it creates a chart, otherwise it shows a message
    if(nrow(data) > 0){
      chart <- rCharts:::Highcharts$new()
      chart$chart(type = "line", width = 1200)
      chart$xAxis(categories = unlist(as.factor(data$day)), title = list(text = "Day"))
      chart$yAxis(title = list(text = "Frequency"))
      chart$data(data[c(names(enrolment_data))])
      chart$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
      return(chart)
    } else {
      shiny::validate(
        need(nrow(data)>0,
             "No data available")
      )
    }
    
    
  })
  
  #downloading the statements data as a csv
  output$downloadStatementsSold <- downloadHandler(
    filename = function() { paste("statements_sold", '.csv', sep='') },
    content = function(file) {
      data <- statementsSoldData()
      write.csv(data, file)
    }
  )
  
  # END SIGN UPS AND STATEMENTS SOLD TAB
  
  
  
  
  
  
  
  
  #START: CHARTS - OTHER
  
  scatterDependency <- eventReactive(input$plotScatterButton, {})
  
  output$correlationsRunSelector <-renderUI({
    chartDependency()
    runs <- paste(input$course1,strsplit(input$run1," - ")[[1]][1], sep = " - ")
    if(input$run2 != "None"){
      runs <- c(runs, paste(input$course2,strsplit(input$run2," - ")[[1]][1], sep = " - "))
    }
    if(input$run3 != "None"){
      runs <- c(runs, paste(input$course3,strsplit(input$run3," - ")[[1]][1], sep = " - "))
    }
    if(input$run4 != "None"){
      runs <- c(runs, paste(input$course4,strsplit(input$run4," - ")[[1]][1], sep = " - "))
    }
    print(selectInput("correlationsRunChooser", label = "Run",
                      choices = runs, width = "550px"))
  })
  
  # Scatter plot
  output$scatterPlot <- renderChart2({
    # Draw the chart when the "chooseCourseButton" AND the "plotScatterButton" are pressed by the user
    chartDependency()
    scatterDependency()
    
    withProgress(message = "Processing...",{
      
    # input$plotScatterButton
    learners <- unlist(strsplit(input$filteredLearners, "[,]"))
    # In case the user has selected the same values for x and y, display an error message
    shiny::validate(
      need(isolate(input$scatterX) != isolate(input$scatterY),
           "X and Y values cannot be identical. Please, choose different ones.")
    )
    # Check selected input for x and get the according data
    if (isolate(input$scatterX) == "comments") {
      cData <- comments_data[[which(names(comments_data) == input$correlationsRunChooser)]]
      if(nrow(cData)>0){
        x <- getNumberOfCommentsByLearner(cData)
      } else {
        x <- -1
      }
      
      xAxisTitle <- "Comments"
    }
    else if (isolate(input$scatterX) == "replies") {
      cData <- comments_data[[which(names(comments_data) == input$correlationsRunChooser)]]
      if(nrow(cData)>0){
        x <- getNumberOfRepliesByLearner(cData)
      } else {
        x <- -1
      }
      
      xAxisTitle <- "Replies"
    }
    else if (isolate(input$scatterX) == "likes") {
      cData <- comments_data[[which(names(comments_data) == input$correlationsRunChooser)]]
      if(nrow(cData)>0){
        x <- getNumberOfLikesByLearner(cData)
      } else {
        x <- -1
      }
      
      xAxisTitle <- "Likes"
    }
    else if (isolate(input$scatterX) == "answers") {
      qData <- quiz_data[[which(names(quiz_data) == input$correlationsRunChooser)]]
      if(nrow(qData)>0){
        x <- getNumberOfResponsesByLearner(qdata)
      } else {
        x <- -1
      }
      
      xAxisTitle <- "Answers"
    }
    else if (isolate(input$scatterX) == "steps") {
      sData <- step_data[[which(names(step_data) == input$correlationsRunChooser)]]
      if(nrow(sData)>0){
        x <- getStepsCompleted(sData)
      } else {
        x <- -1
      }
      
      xAxisTitle <- "Completed (%)"
    }
    else if (isolate(input$scatterX) == "correct") {
      qData <- quiz_data[[which(names(quiz_data) == input$correlationsRunChooser)]]
      if(nrow(qData)>0){
        x <- getResponsesPercentage(qData)
        x <- x[c("learner_id", "correct")]
      } else {
        x <- -1
      }
      
      xAxisTitle <- "Correct (%)"
    }
    else if (isolate(input$scatterX) == "wrong") {
      qData <- quiz_data[[which(names(quiz_data) == input$correlationsRunChooser)]]
      if(nrow(qData)>0){
        x <- getResponsesPercentage(qData)
        x <- x[c("learner_id", "wrong")]
      } else {
        x <- -1
      }
      
      xAxisTitle <- "Wrong (%)"
    }
    else if (isolate(input$scatterX) == "questions") {
      qData <- quiz_data[[which(names(quiz_data) == input$correlationsRunChooser)]]
      if(nrow(qData)>0){
        x <- getPercentageOfAnsweredQuestions(qData)
      } else {
        x <- -1
      }
      
      xAxisTitle <- "Questions (%)"
    }
    # Check selected input for y and get the according data
    if (isolate(input$scatterY) == "comments") {
      cData <- comments_data[[which(names(comments_data) == input$correlationsRunChooser)]]
      if(nrow(cData)>0){
        y <- getNumberOfCommentsByLearner(cData)
      } else {
        y <- -1
      }
      
      yAxisTitle <- "Comments"
    }
    else if (isolate(input$scatterY) == "replies") {
      cData <- comments_data[[which(names(comments_data) == input$correlationsRunChooser)]]
      if(nrow(cData)>0){
        y <- getNumberOfRepliesByLearner(cData)
      } else {
        y <- -1
      }
      
      yAxisTitle <- "Replies"
    }
    else if (isolate(input$scatterY) == "likes") {
      cData <- comments_data[[which(names(comments_data) == input$correlationsRunChooser)]]
      if(nrow(cData)>0){
        y <- getNumberOfLikesByLearner(cData)
      } else {
        y <- -1
      }
      
      yAxisTitle <- "Likes"
    }
    else if (isolate(input$scatterY) == "answers") {
      qData <- quiz_data[[which(names(quiz_data) == input$correlationsRunChooser)]]
      if(nrow(qData)>0){
        y <- getNumberOfResponsesByLearner(qData)
      } else {
        y <- -1
      }
      
      yAxisTitle <- "Answers"
    }
    else if (isolate(input$scatterY) == "steps") {
      sData <- step_data[[which(names(step_data) == input$correlationsRunChooser)]]
      if(nrow(sData) > 0){
        y <- getStepsCompleted(sData)
      } else {
        y <- -1
      }
      
      yAxisTitle <- "Completed (%)"
    }
    else if (isolate(input$scatterY) == "correct") {
      qData <- quiz_data[[which(names(quiz_data) == input$correlationsRunChooser)]]
      if(nrow(qData) > 0){
        y <- getResponsesPercentage(qData)
        y <- y[c("learner_id", "correct")]
      } else {
        y <- -1
      }
      
      yAxisTitle <- "Correct (%)"
    }
    else if (isolate(input$scatterY) == "wrong") {
      qData <- quiz_data[[which(names(quiz_data) == input$correlationsRunChooser)]]
      if(nrow(qData)>0){
        y <- getResponsesPercentage(qData)
        y <- y[c("learner_id", "wrong")]
      } else {
        y <- -1
      }
      
      yAxisTitle <- "Wrong (%)"
    }
    else if (isolate(input$scatterY) == "questions") {
      qData <- quiz_data[[which(names(quiz_data) == input$correlationsRunChooser)]]
      if(nrow(qData)>0){
        y <- getPercentageOfAnsweredQuestions(qData)
      } else {
        y <- -1
      }
      
      yAxisTitle <- "Questions (%)"
    }
    updateTextInput(session, "scatterSlopeValue", value = "No data available")
    if(x == -1 || y == -1){
      shiny::validate(
        need(x != -1 && y != -1,
             "No data available")
      )
    } else {
      # Merge the x and y data frames together and rename the columns
      plotData <- merge(x, y, by = "learner_id")
      
      colnames(plotData)[c(2,3)] <- c("x", "y")
      # Produce the regression model 
      regressionModel <- lm(x ~ y, data = plotData)
      # Find the slope and assign it to a global variable
      updateTextInput(session, "scatterSlopeValue", value = as.character(coef(regressionModel)[2]))
      # Convert the regression model to a data frame
      regressionData <- fortify(regressionModel)
      # Extract the line of best fit
      regressionData$x <- regressionData$`.fitted`
      # Reorder and rename the columns
      regressionData <- regressionData[,c(2, 1)]
      colnames(regressionData) <- c("x", "y")
      # Get the start and end coordinates of the line of best fit
      #I think it was used before to create the regression line using the first and last point
      # startPoint <- subset(regressionData, y == min(y))
      # startPoint <- startPoint[1,]
      # endPoint <- subset(regressionData, y == max(y))
      # endPoint <- endPoint[1,]
      # regressionData <- rbind(startPoint, endPoint)
      
      # Create the scatter plot and pass in some options
      scatter <- hPlot(x ~ y, data = plotData, type = "scatter", color = "completed")
      scatter$chart (width = 1200, height = 600, zoomType = "xy")
      scatter$series (list(
        list(
          data = toJSONArray2(regressionData, json = FALSE, names = FALSE), 
          type = "line",
          marker = list(enabled = FALSE)
        )
      ))
      scatter$xAxis (title = list(text = yAxisTitle), ticks = 15, min = 0)
      scatter$yAxis (title = list(text = xAxisTitle), ticks = 15, min = 0, max = 100)
      scatter$tooltip (formatter = "#! function() { return 'Comments: '     + this.point.y + '<br />' +
																 'Completed: '    + this.point.x.toFixed(2)  + '<br />'; } !#")
      
      return (scatter)
    }
    
  })
  })
  output$dateTimeSeries <- renderDygraph({
    chartDependency()
    learners <- unlist(strsplit(input$filteredStreams, "[,]"))
    #calculate the comments, like and replies by date
    
    comments <- getNumberOfCommentsByDate(comments_data)
    likes <-  getNumberOfLikesByDate(comments_data)
    replies <- getNumberOfRepliesByDate(comments_data)
    answers <- getNumberOfResponsesByDateTime(quiz_data)
    enrolment <- getEnrolmentByDateTime(enrolment_data)
    
    #convert them to time series objects so dygraph can plot them
    commentsXts <- xts(as.matrix(comments[,-1]),as.POSIXct(comments[,1],format='%Y-%m-%d %H', tz= "GMT"))
    likesXts <- xts(as.matrix(likes[,-1]),as.POSIXct(likes[,1],format='%Y-%m-%d %H', tz= "GMT"))
    repliesXts <- xts(as.matrix(replies[,-1]),as.POSIXct(replies[,1],format='%Y-%m-%d %H', tz= "GMT"))
    answersXts <- xts(as.matrix(answers[,-1]),as.POSIXct(answers[,1],format='%Y-%m-%d %H', tz= "GMT"))
    enrolmentXts <- xts(as.matrix(enrolment[,-1]),as.POSIXct(enrolment[,1],format='%Y-%m-%d %H', tz= "GMT"))
    #combine the series
    plotData <- cbind(commentsXts, repliesXts, likesXts, answersXts, enrolmentXts)
    plotData <- na.fill(plotData, 0)
    for (i in 1:nrow(plotData)) {
      if (plotData[i,5] == 0) {
        plotData[i,5] = plotData[i-1,5]
      }
    }
    colnames(plotData) <- c("comments", "replies", "likes", "answers", "enrolment")
    plotData$comments <- cumsum(plotData$comments)
    plotData$replies <- cumsum(plotData$replies)
    plotData$likes <- cumsum(plotData$likes)
    plotData$answers <- cumsum(plotData$answers)
    #plot all the series in one chart, passing it some options
    dygraph(plotData) %>%
      dySeries("comments", label = "Comments") %>%
      dySeries("replies", label = "Likes") %>%
      dySeries("likes", label = "Replies") %>%
      dySeries("answers", label = "Answers") %>%
      dySeries("enrolment", label = "Enrolment") %>%
      #for some reason, useDataTimezone stopped working
      dyOptions(stepPlot = FALSE, fillGraph = FALSE, drawGrid = FALSE, useDataTimezone = TRUE) %>%
      dyLegend(show = "always", hideOnMouseOut = TRUE, width = 700) %>%
      dyRangeSelector() %>%
      dyRoller(rollPeriod  = 1) %>%
      dyHighlight(highlightCircleSize = 5, 
                  highlightSeriesBackgroundAlpha = 0.2,
                  hideOnMouseOut = TRUE,
                  highlightSeriesOpts = list(strokeWidth = 2))
  })
  
  output$network <- renderForceNetwork({
    chartDependency()

    com <- comments_data
    input$resetButton
    start <- startDate
    end <- endDate
    net <- getNetworkByLearner(com)

    #net <- net[as.Date(net$Timestamp) >= start & as.Date(net$Timestamp) <= end,]
    id <- unique(c(net$Givers,net$Receivers))
    node <<- data.frame(id)
    src <- apply(as.matrix(net$Givers),1,function(x) match(x,id))
    tag <- apply(as.matrix(net$Receivers),1,function(x) match(x,id))
    src <- src - 1
    tag <- tag - 1
    link <<- data.frame(src,tag)
    link <- dcast(link,src + tag ~ 'value',length)

    giver <- unique(net$Givers)
    receiver <- unique(net$Receivers)
    group <- apply(as.matrix(id),1,function(x) if(!is.na(match(x,giver)) & !is.na(match(x,receiver))) 'both' else if (!is.na(match(x,giver))) 'giver' else 'receiver')
    node$group <- group
    node$size <- 5
    forceNetwork(link,node,Source ='src',Target = 'tag', Nodesize = 'size',radiusCalculation = JS("d.nodesize"),
                 linkWidth = JS("function(d) { return d.value
														; }"), linkColour = "#000000",opacity = 0.9,
                 Value = 'value',NodeID = 'id',Group = 'group',zoom =  T, legend = T,colourScale = 'd3.scale.category10()',
                 clickAction = 'var pos = d3.transform(d3.select(this).attr("transform")).translate;
														var x = pos[0];
														var y = pos[1];
														var line = d3.selectAll("line");
														var size = line.size();
														var lines = line[0];
														for (var i = 0;i < size; i ++){
															l = lines[i]
																if((x == l.x1.animVal.value && y == l.y1.animVal.value) || (x == l.x2.animVal.value && y == l.y2.animVal.value)){
																			if( l.style["stroke"] == "rgb(255, 0, 0)" ){
																					l.style["stroke"] = "rgb(0,0,0)";
																			}else{
																					l.style["stroke"] = "rgb(255,0,0)";
																			}
																}
														}
														 '


    )
  })

  output$densityAndReciprocity <- renderDygraph({
    chartDependency()
    comments <- comments_data
    comments$timestamp <- as.POSIXct(comments$timestamp, format = '%Y-%m-%d', tz= "UTC")
    density <- getDensityByDate(getNewLearnersByDate(comments),getNewConnectionByDate(comments))
    reciprocity <- getReciprocityByDate(comments)
    data <- getFinalData(density,reciprocity)
    
    
    d <- xts(data$Density,as.POSIXct(data$timestamp,format='%Y-%m-%d', tz= "UTC"))
    r <- xts(data$Reciprocity*100,as.POSIXct(data$timestamp,format='%Y-%m-%d', tz= "UTC"))
    plotData <- cbind(d,r)
    dygraph(plotData, main = 'Density and Reciprocity', x = 'Date') %>%  
      dySeries("..1", label = "Density") %>%
      dySeries("..2", label = "Reciprocity") %>%
      dyRangeSelector()
    
  })
  
  output$degreeGraph <- renderDygraph({
    chartDependency()
    degree <- getDegreeByLearner(comments_data)
    plotData <- data.frame()
    for (n in 2:ncol(degree)){
      x <- xts(degree[,n], as.POSIXct(degree$timestamp,format='%Y-%m-%d', tz= "UTC"))
      plotData <- cbind(plotData,x)
      
    }
    
    colnames(plotData) <- paste(substr(colnames(degree)[2:ncol(degree)],0,5),'..',sep ='')
    dygraph(plotData, main = 'Degree(top 7 learners)', x = 'Date') %>%  
      dyLegend(show = 'onmouseover', hideOnMouseOut = T) %>%
      dyRangeSelector()
  })
  
  # Data table showing learner information for each run.
  output$aggregateEnrolmentData <- renderDataTable({
    
    courseMetaData <- courseMetaData[, !(colnames(courseMetaData) %in% c("course","run"))]
    courseMetaData$course_run <- gsub( "-", " ", as.character(courseMetaData$course_run))
    courseMetaData$course_run <- capitalize(courseMetaData$course_run)
    courseMetaData <- courseMetaData[order(courseMetaData$course_run),]
    courseMetaData$start_date <- as.Date(courseMetaData$start_date)
    courseMetaData <- courseMetaData[ , !(names(courseMetaData) %in% c("university"))]
    
    DT::datatable(
      courseMetaData, class = 'cell-border stripe', filter = 'top', extensions = 'Buttons',
      colnames = c('Leavers (Joiners who leave the course)' = 6,
                   'Leavers %' = 7,
                   'Learners (Joiners who view a step)' = 8,
                   'Learners %' = 9,
                   'Active Learners (Learners who mark as complete)' = 10,
                   'Active Learners %'  = 11,
                   'Returning Learners (Learners who mark as complete in two weeks)' = 12,
                   'Returning Learners %'  = 13,
                   'Social Learners (Learners who make comments)' = 14,
                   'Social Learners %'  = 15,
                   'Fully Participating Learners (Learners who complete 50% of steps + assements)' = 16,
                   'Fully Participating Learners %'  = 17,
                   'Statements Sold' = 18,
                   'Certificates Sold' = 19,
                   'upgrades Sold' = 20,
                   'upgrades Sold %'  = 21,
                   'Learners with ≥50% step completion)' = 22,
                   '≥50% step completion %'  = 23,
                   'Learners with ≥90% step completion)' = 24,
                   '≥90% step completion %'  = 25,
                   'Run Retention Index' = 26,
                   'Run Retention Index %' = 27,
                   'Gross Revenue Index GBP' = 28),

      options = list(
        lengthMenu = list(c(10,20,30,-1),c('10','20','30','All')),
        pageLength = 20,
        scrollX = TRUE,
        dom = 'lfrtBip',
        columnDefs = list(list(visible=FALSE, targets=c(1))),
        buttons = list(
          "print",
          list(
            extend = 'pdf',
            filename = paste(institution,'Mooc Enrolment Data', Sys.Date()),
            orientation = 'landscape',
            text = 'Download PDF'),
          list(
            extend = 'excel',
            filename = paste(institution,'Mooc Enrolment Data', Sys.Date()),
            text = 'Download Excel'
          ),
          list(
            extend = 'csv',
            filename = paste(institution,'Mooc Enrolment Data', Sys.Date()),
            text = 'Download CSV'
          )
        )
      ),
      rownames = FALSE
    )
  })
  
  # Valuebox aggregating the number of joiners in all courses
  output$totalJoiners <- renderValueBox({
    valueBox("Total Joiners", subtitle = sum(courseMetaData$joiners), icon = icon("group"), color = "red")
  })
  
  # Valuebox aggregating the number of learners in all courses
  output$totalLearners <- renderValueBox({
    learners <- subset(courseMetaData , learners != "N/A")
    learners2 <- sapply(learners$learners, function(x) strsplit(toString(x), "-"))
    learners3 <- sapply(learners2, function(x) as.numeric(x[[1]]))
    valueBox("Total Learners", subtitle = sum(learners3), icon = icon("group"), color = "red")
  })
  
  #Valuebox aggregating the number of statements sold in all courses
  output$totalStatementsSold <- renderValueBox({
    valueBox("Total Statements Sold", subtitle = sum(courseMetaData$statements_sold), icon = icon("certificate"), color = "red")
  })
  
  # END AGGREGATE ENROLMENT TAB
  
  
  # START STEP COMPLETION TAB
  
  # Selector for which run to display on the step tab
  
  
  
  
  StepButtonDependency <- eventReactive(input$runSelectorStepsButton, {})
  
  output$runSelectorSteps <- renderUI({
  #  StepButtonDependency()
    chartDependency()
    #stepDependancy()
    
    isolate({runs <- paste(input$course1,strsplit(input$run1," - ")[[1]][1], sep = " - ")
    if(input$run2 != "None"){
      runs <- c(runs, paste(input$course2,strsplit(input$run2," - ")[[1]][1], sep = " - "))
    }
    if(input$run3 != "None"){
      runs <- c(runs, paste(input$course3,strsplit(input$run3," - ")[[1]][1], sep = " - "))
    }
    if(input$run4 != "None"){
      runs <- c(runs, paste(input$course4,strsplit(input$run4," - ")[[1]][1], sep = " - "))
    }})
    print(selectInput("runChooserSteps", label = "Run", choices = runs, width = "550px"))
  })
  
  avgRegLineSMC <- NULL
  avgRegLineSFV <- NULL
  
  observeEvent(input$runSelectorStepsButton, {
   
    if (isolate(input$graphName) == "StepsMarkedAsComplete") {
      # Step completed column chart
      # output$StepsFirstVisited <- renderChart2({})
      # output$stepCompletionHeat <- renderD3heatmap({})
      # output$firstVisitedHeat <- renderD3heatmap({})
      # output$firstVisitedPerDay <- renderChart2({})
      # output$markedCompletedPerDay <- renderChart2({})
      shinyjs::hide(id = "box2")
      shinyjs::hide(id = "box3")
      shinyjs::hide(id = "box4")
      shinyjs::hide(id = "box5")
      shinyjs::hide(id = "box6")
      shinyjs::show(id = "box1")
      
      #two variables to store information about the regression lines
      regLineSMC <- NULL
      
      output$stepsCompleted <- renderChart2({
        
        withProgress(message = "Processing",{
          
          isolate({runChooserSteps <- input$runChooserSteps})
          
          sData <- step_data[[which(names(step_data) == runChooserSteps)]]
          
          
          if(nrow(sData)>0){
            
            #counts the number of times each step was marked as completed 
            stepsCount <- getStepsCompletedData(sData)
            
            #store the average regression line in a global variable to compute it only once
            if(is.null(avgRegLineSMC)){
              #gets a data frame with step data for each course and run
              s <- getAllStepCompletedData(getAllTableData("Activity"))
              avgRegLineSMC <<- computeAverageRegressionLine(s)
            }
            
            #add an id column for computing the regression line (as the step numbers can't be used)
            stepsCount$id <- seq.int(nrow(stepsCount))
            
            #computing the regression line points
            stepsCount$totalAvg <- avgRegLineSMC[2] * stepsCount$id + avgRegLineSMC[1]
            
            
            #computing the graphs
            a <- rCharts:::Highcharts$new()
            a$chart(type = "column", width = 1200)
            a$series(name = runChooserSteps,
                     type = "column",
                     data = stepsCount$freq
            )
            a$xAxis(categories = unlist(as.factor(stepsCount[,c("week_step")])), title = list(text = "Step"))
            a$yAxis(title = list(text = "Frequency"))
            
            a$plotOptions(
              column = list(
                animation = FALSE
              ),
              line = list(
                animation = FALSE)
            )
            
            #creating the regression model and data for the current course run
            model <- lm(freq ~ id, stepsCount)
            #print(summary(model))
            
            fit <- fortify(model)
            
            #extracting the slope
            slope <- coef(model)[2]
            
            #storing all the reg line info in a variable
            regLineSMC <<- c(coef(model)[1], slope, summary(model)$coefficients[2,2], model$df.residual + 2)
            names(regLineSMC) <<- c("Const", "Slope", "StdError", "SampleSize")
              
            #making sure the average regression line values do not go below 0
            stepsCount <- stepsCount[which(stepsCount$totalAvg > 0), ]
            
            #displaying the regression lines
            a$series(name = "Regression line",
                     type = "line",
                     data = fit$.fitted,
                     marker = list(enabled = FALSE)
            )
            a$series(name = "Avg Regression line",
                     type = "line",
                     color = "#3115e5",
                     data = stepsCount$totalAvg,
                     marker = list(enabled = FALSE)
            )
            return(a)
          } else {
            #if there is no data available it shows an error message
            shiny::validate(
              need(nrow(sData)>0,
                   "No data available")
            )
          }
        })
      })
      
      #instruction to run a significance test to check the difference of the two slopes
      output$runTestTextSMC <- renderText({
        "Run a test to check if the difference between the slope of the regression line of the selected course and the average slope of all regression lines is statistically significant"
      })
      
      #Selector to choose the alpha value for the statistical significance
      output$alphaValueSelectorSMC <- renderUI({
        alphaValues <- c(0.1, 0.05, 0.01)
        print(selectInput("alphaValueSelectorSMC", label = "Choose alpha:", choices = alphaValues, width = "550px"))
      })
      
      # Run statistical significance test button
      output$runTestButtonSMC <- renderUI({
        print(actionButton("runTestButtonSMC","Run test"))
      })
      
      #to perform the test when pressing the button
      observeEvent(input$runTestButtonSMC, {
        
        #the chosen alpha value
        alpha <- as.numeric(input$alphaValueSelectorSMC)
        
        db <- regLineSMC[2] - avgRegLineSMC[2]
        
        #one of these 2 formulas of sd and df should be the correct ones
        #the first one is for comparing the slopes of 2 different regression lines
        #the second one is for comparing the slope of a regression line with a value
        #sd <- sqrt(regLine1[3]^2 + avgRegLine1[3]^2)
        sd <- regLineSMC[3]
        
        t_value <- db/sd
        
        #df <- avgRegLineSMC[4] + regLineSMC[4] - 4
        df <- regLineSMC[4] - 2
        
        #calculating the p-value
        p_value <- 2*pt(-abs(t_value), df)
        
        #printing the result of the test
        output$testResultSMC <- renderText({
          if(p_value <= alpha){
            return (paste("Test result: there is a statistically significant difference between the two slope values, at p = ", p_value, "and alpha = ", alpha))
          } else {
            return (paste("Test result: there is NO statistically significant difference between the two slope values, at p = ", p_value, "and alpha = ", alpha))
          }
        })
      })
      
    }
    else if (isolate(input$graphName) == "StepsFirstVisited") {
      # Step completed column chart
      # output$stepsCompleted <- renderChart2({})
      # output$stepCompletionHeat <- renderD3heatmap({})
      # output$firstVisitedHeat <- renderD3heatmap({})
      # output$firstVisitedPerDay <- renderChart2({})
      # output$markedCompletedPerDay <- renderChart2({})
      shinyjs::hide(id = "box1")
      shinyjs::hide(id = "box3")
      shinyjs::hide(id = "box4")
      shinyjs::hide(id = "box5")
      shinyjs::hide(id = "box6")
      shinyjs::show(id = "box2")
      
      regLineSFV <- NULL
      
      output$StepsFirstVisited <- renderChart2({
        
        withProgress(message = "Processing",{
          
          #gets the step data for the selected course run
          isolate({runChooserSteps <- input$runChooserSteps})
          
          sData <- step_data[[which(names(step_data) == runChooserSteps)]]
          
          #checks if the data is empty or not
          if(nrow(sData)>0){
            #counts the number of times each step was first visited
            stepsCount <- getStepsFirstVistedData(sData)
            
            #rceating an id column needed for the regression model
            stepsCount$id <- seq.int(nrow(stepsCount))
            
            if(is.null(avgRegLineSFV)){
              #gets a data frame with step data for each course and run
              s <- getAllStepsFirstVisitedData(getAllTableData("Activity"))
              avgRegLineSFV <<- computeAverageRegressionLine(s)
            }
            
            stepsCount$totalAvg <- avgRegLineSFV[2] * stepsCount$id + avgRegLineSFV[1]
            
            #creating the chart
            a <- rCharts:::Highcharts$new()
            a$chart(type = "column", width = 1200)
            a$series(
              name = runChooserSteps,
              type = column,
              data = stepsCount$freq
            )
            a$xAxis(categories = unlist(as.factor(stepsCount[,c("week_step")])), title = list(text = "Step"))
            a$yAxis(title = list(text = "Frequency"))
            a$plotOptions(
              column = list(
                animation = FALSE
              ),
              line = list(
                animation = FALSE)
            )
            
            #creating the regression model and data
            print(stepsCount)
            model <- lm(freq ~ id, stepsCount)
            fit <- fortify(model)

            #storing information about the regression line in a single variable
            if(!is.na(coef(model)[1]) && !is.na(coef(model)[2]) && !is.na(summary(model)$coefficients[2,2]) && !is.na(model$df.residual + 2)){
              regLineSFV <<- c(coef(model)[1], coef(model)[2], summary(model)$coefficients[2,2], model$df.residual + 2)
              names(regLineSFV) <<- c("Const", "Slope", "StdError", "SampleSize")
            }

            #making sure the average regression line values do not go below 0
            stepsCount <- stepsCount[which(stepsCount$totalAvg > 0), ]

            #displaying the regression line
            a$series(name = "Regression line",
                     type = "line",
                     data = fit$.fitted,
                     marker = list(enabled = FALSE))
            a$series(name = "Avg Regression line",
                     type = "line",
                     color = "#3115e5",
                     data = stepsCount$totalAvg,
                     marker = list(enabled = FALSE)
                     
            )
            
            return(a)
          } else {
            #if there is no data available it shows an error message
            shiny::validate(
              need(nrow(sData)>0,
                   "No data available")
            )
          }
          
        })
        
      })
      
      #instructing to use a statistical significance test to check if the difference between the two slopes is significant
      output$runTestTextSFV <- renderText({
        "Run a test to check if the difference between the slope of the regression line of the selected course and the average slope of all regression lines is statistically significant"
      })
      
      #Selector to choose the alpha value for the statistical significance
      output$alphaValueSelectorSFV <- renderUI({
        alphaValues <- c(0.1, 0.05, 0.01)
        print(selectInput("alphaValueSelectorSFV", label = "Choose alpha:", choices = alphaValues, width = "550px"))
      })
      
      # Run statistical significance test button
      output$runTestButtonSFV <- renderUI({
        print(actionButton("runTestButtonSFV","Run test"))
      })
      
      #performing the statistical test when pressing the button
      observeEvent(input$runTestButtonSFV, {
        
        fail = FALSE
        if(is.null(regLineSFV)){
          fail = TRUE
        } else {
          #the chosen alpha value
          alpha <- as.numeric(input$alphaValueSelectorSFV)
          
          db <- regLineSFV[2] - avgRegLineSFV[2]
          
          #one of these 2 formulas should be the right one
          #sd <- sqrt(regLineSFV[3]^2 + avgRegLineSFV[3]^2)
          sd <- regLineSFV[3]
          
          t_value <- db/sd
          
          df <- regLineSFV[4] - 2
          
          #calculating the p-value
          p_value <- 2*pt(-abs(t_value), df)
        }
        
        #printing the result of the test
        output$testResultSFV <- renderText({
          if(fail){
            return("Not enough data")
          } else {
            if(p_value <= alpha){
              return (paste("Test result: there is a statistically significant difference between the two slope values, at p = ", p_value, "and alpha = ", alpha))
            } else {
              return (paste("Test result: there is NO statistically significant difference between the two slope values, at p = ", p_value, "and alpha = ", alpha))
            }
          }
        })
      })
    }
    else if (isolate(input$graphName) == "StepsFirstVisitedByStepAndDate") {
      # Step completion heat map
      # output$StepsFirstVisited <- renderChart2({})
      # output$stepsCompleted <- renderChart2({})
      # output$stepCompletionHeat <- renderD3heatmap({})
      # output$firstVisitedPerDay <- renderChart2({})
      # output$markedCompletedPerDay <- renderChart2({})
      shinyjs::hide(id = "box1")
      shinyjs::hide(id = "box2")
      shinyjs::hide(id = "box4")
      shinyjs::hide(id = "box5")
      shinyjs::hide(id = "box6")
      shinyjs::show(id = "box3")
      output$firstVisitedHeat <- renderD3heatmap({
        
       withProgress(message = "Processing",{
          
         isolate({
            #gets the start date of the course run which is selected
            startDate <- course_data[[which(names(course_data) == input$runChooserSteps)]]$start_date
          
            #gets the step data for the selected course run
            sData <- step_data[[which(names(step_data) == input$runChooserSteps)]]
         })
         
          if(nrow(sData)!=0){
            #gets the data for the heat map, passing the step data for the course run and the start date
            map <- getFirstVisitedHeatMap(sData, startDate)
            
            #There are 2 possibilities to color the heatmap:
            #1 (implemented now) with shades of blue starting from white to dark blue
            #2 - where only 0s are white and the rest start from blue to dark blue
            #replacing all 0s with null to make them white in the heatmap for #2, and scale should be column in the code below 
            #replacing all 0s with null to make them white in the heatmap
            #map[map == 0]<-NA
            
            d3heatmap(map[,2:ncol(map)],
                             dendrogram = "none",
                             scale = "none",  
                             #scale = "column",
                             color = "Blues",
                             labRow = as.character(as.POSIXct(map[,1]), origin = "1970-01-01"))
          } else {
            shiny::validate(
              need(nrow(sData)>0,
                   "No data available")
            )
          }
        })
        
        
      })
    }
    else if (isolate(input$graphName) == "StepsFirstVisitedPerDay") {
      # Step completion heat map
      # output$StepsFirstVisited <- renderChart2({})
      # output$stepsCompleted <- renderChart2({})
      # output$firstVisitedHeat <- renderD3heatmap({})
      # output$stepCompletionHeat <- renderD3heatmap({})
      # output$markedCompletedPerDay <- renderChart2({})
      shinyjs::hide(id = "box1")
      shinyjs::hide(id = "box2")
      shinyjs::hide(id = "box3")
      shinyjs::hide(id = "box5")
      shinyjs::hide(id = "box6")
      shinyjs::show(id = "box4")
      output$firstVisitedPerDay <- renderChart2({
        chartDependency()
        
        withProgress(message = "Processing",{
          
          data<-stepsFirstVisitedPerDay()
          
          if(nrow(data)>0){
            chart <- Highcharts$new()
            chart$chart(type = "line", width = 1200)
            chart$data(data[c(names(step_data))])
            chart$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
            chart$xAxis(categories = unlist(as.factor(data$day)), title = list(text = "Day"))
            chart$yAxis(title = list(text = "Frequency"))
            return(chart)
          } else {
            shiny::validate(
              need(nrow(data)>0,
                   "No data available")
            )
          }
          
          
        })
      })
    }
    else if (isolate(input$graphName) == "StepsMarkedCompletedPerDay") {
      # Step completion heat map
      # output$StepsFirstVisited <- renderChart2({})
      # output$stepsCompleted <- renderChart2({})
      # output$firstVisitedHeat <- renderD3heatmap({})
      # output$stepCompletionHeat <- renderD3heatmap({})
      # output$firstVisitedPerDay <- renderChart2({})
      shinyjs::hide(id = "box1")
      shinyjs::hide(id = "box2")
      shinyjs::hide(id = "box3")
      shinyjs::hide(id = "box4")
      shinyjs::hide(id = "box6")
      shinyjs::show(id = "box5")
      output$markedCompletedPerDay <- renderChart2({
        chartDependency()
        
        withProgress(message = "Processing",{
          
          data<-stepsMarkedCompletedPerDay()
          
          if(nrow(data) > 0){
            chart <- Highcharts$new()
            chart$chart(type = "line", width = 1200)
            chart$data(data[c(names(step_data))])
            chart$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
            chart$xAxis(categories = unlist(as.factor(data$day)), title = list(text = "Day"))
            chart$yAxis(title = list(text = "Frequency"))
            return(chart)
          } else {
            shiny::validate(
              need(nrow(data)>0,
                   "No data available")
            )
          }
          
          
        })
      })
    }
    else if (isolate(input$graphName) == "StepsMarkedAsCompleteByStepAndDate") {
      # First Visited Heat Map
      # output$StepsFirstVisited <- renderChart2({})
      # output$stepsCompleted <- renderChart2({})
      # output$stepCompletionHeat <- renderD3heatmap({})
      # output$firstVisitedPerDay <- renderChart2({})
      # output$markedCompletedPerDay <- renderChart2({})
      shinyjs::hide(id = "box1")
      shinyjs::hide(id = "box2")
      shinyjs::hide(id = "box3")
      shinyjs::hide(id = "box4")
      shinyjs::hide(id = "box5")
      shinyjs::show(id = "box6")
      output$stepCompletionHeat <- renderD3heatmap({
        
        withProgress(message = "Processing",{
          
          isolate({
            #gets the start date of the selected course run
            startDate <- course_data[[which(names(course_data) == input$runChooserSteps)]]$start_date
            
            #gets the step data of the selected course run
            sData <- step_data[[which(names(step_data) == input$runChooserSteps)]]
          })
          #if the table contains data it computes the necessary data and renders the heatmap
          #otherwise shows an error message
          if(nrow(sData)>0){
            map <- getStepCompletionHeatMap(sData, startDate)
            
            #There are 2 possibilities to color the heatmap:
            #1 (implemented now) with shades of blue starting from white to dark blue
            #2 - where only 0s are white and the rest start from blue to dark blue
            #replacing all 0s with null to make them white in the heatmap for #2, and scale should be column in the code below 
            #map[map == 0]<-NA
            
            return((d3heatmap(map[,2:ncol(map)],
                              dendrogram = "none",
                              #scale = "column",
                              scale = "none",
                              color = "Blues",
                              labRow = as.character(as.POSIXct(map[,1]), origin = "1970-01-01"))))
          } else {
            shiny::validate(
              need(nrow(sData)>0,
                   "No data available")
            )
          }
        })
      })
    }
  })
  
  # END STEP COMPLETION TAB
  
  
  #START: CHARTS - COMMENTS ORIENTATED
  
  # Selector for which run to display comment related things
 # CommentButtonDependency <- eventReactive(input$runSelectorCommentsButton, {})
  
  output$runSelectorComments <- renderUI({
    chartDependency()
    runs <- paste(input$course1,strsplit(input$run1," - ")[[1]][1], sep = " - ")
    if(input$run2 != "None"){
      runs <- c(runs, paste(input$course2,strsplit(input$run2," - ")[[1]][1], sep = " - "))
    }
    if(input$run3 != "None"){
      runs <- c(runs, paste(input$course3,strsplit(input$run3," - ")[[1]][1], sep = " - "))
    }
    if(input$run4 != "None"){
      runs <- c(runs, paste(input$course4,strsplit(input$run4," - ")[[1]][1], sep = " - "))
    }
    print(selectInput("runChooserComments", label = "Run", choices = runs, width = "550px"))
  })
  
  observeEvent(input$runSelectorCommentsButton, {
    
    if (isolate(input$commentovervewGraph) == "NumberofCommentsbyStep") {
      shinyjs::hide(id = "commentBox2")
      shinyjs::hide(id = "commentBox3")
      shinyjs::hide(id = "commentBox4")
      shinyjs::hide(id = "commentBox5")
      shinyjs::show(id = "commentBox1")
      output$commentsBarChart <- renderChart2({
        
        #to update if the go button is pressed 
        chartDependency()
        
        withProgress(message = "Processing",{
          
          #step and comment data for the selected course run
          isolate({runChooserComments <- input$runChooserComments})
          
          sData <- step_data[[which(names(step_data) == runChooserComments)]]
          cData <- comments_data[[which(names(comments_data) == runChooserComments)]]
          
          #checking to see if the data needed to compute the chart is empty or not
          #if empty it displays an error message, if not it renders the chart
          if(nrow(sData)>0 && nrow(cData)>0){
            plotData <- getCommentsBarChart(sData,cData)
            histogram <- Highcharts$new()
            histogram$chart(type = "column" , width = 1200)
            histogram$data(plotData[,c("reply","post")])
            histogram$xAxis (categories = plotData$week_step, title = list(text = "Activity step"))
            histogram$yAxis(title = list(text = "Frequency"))
            histogram$title(text = runChooserComments)
            histogram$plotOptions (
              column = list(
                stacking = "normal"
              ),
              animation = FALSE
            )
            return(histogram)
          } else {
            shiny::validate(
              need(nrow(sData)>0 && nrow(cData)>0,
                   "No data available"))
          }
        })
      })
    }
    else if (isolate(input$commentovervewGraph) == "NumberofCommentsperDay") {
      shinyjs::hide(id = "commentBox1")
      shinyjs::hide(id = "commentBox3")
      shinyjs::hide(id = "commentBox4")
      shinyjs::hide(id = "commentBox5")
      shinyjs::show(id = "commentBox2")
      output$commentsPerDayBarChart <- renderChart2({
        chartDependency()
        
        withProgress(message = "Processing",{
          
          data<-commentsPerDay()
          chart <- Highcharts$new()
          chart$chart(type = "line", width = 1200)
          chart$data(data[c(names(comments_data))])
          chart$colors('#7cb5ec', '#434348','#8085e9','#00ffcc')
          chart$xAxis(categories = data$day)
          chart$yAxis(title = list(text = "Frequency"))
          return(chart)
        })
      })
    }
    else if (isolate(input$commentovervewGraph) == "NumberofCommentsbyStepandDate") {
      shinyjs::hide(id = "commentBox1")
      shinyjs::hide(id = "commentBox2")
      shinyjs::hide(id = "commentBox4")
      shinyjs::hide(id = "commentBox5")
      shinyjs::show(id = "commentBox3")
      # Heatmap of comments made per step and date
      output$stepDateCommentsHeat <- renderD3heatmap({
        
        # Draw the chart when the "chooseCourseButton" is pressed by the user
        chartDependency()
        
        withProgress(message = "Processing",{
          
          learners <- unlist(strsplit(input$filteredLearners, "[,]"))
          
          isolate({runChooserComments <- input$runChooserComments})
          
          startDate <- course_data[[which(names(course_data) == runChooserComments)]]$start_date
          cData <- comments_data[[which(names(comments_data) == runChooserComments)]]
          
          #renders the heatmap if there is existing data and shows an error message if not
          if(nrow(cData)>0){
            comments <- getCommentsHeatMap(cData, startDate)
            
            #There are 2 possibilities to color the heatmap:
            #1 (implemented now) with shades of blue starting from white to dark blue
            #2 - where only 0s are white and the rest start from blue to dark blue
            #replacing all 0s with null to make them white in the heatmap for #2, and scale should be column in the code below 
            #comments[comments == 0]<-NA
            
            d3heatmap(comments[,2:ncol(comments)], dendrogram = "none", 
                      color = "Blues",
                      #scale = "column",
                      scale = "none", 
                      labRow = as.character(as.POSIXct(comments[,1], origin = "1970-01-01")),
                      labCol = colnames(comments)[-1])
          } else {
            shiny::validate(
              need(nrow(cData)>0,
                   "No data available"))
          }
        })
      })
    }
    else if (isolate(input$commentovervewGraph) == "CommentsandRepliesbyWeek") {
      shinyjs::hide(id = "commentBox1")
      shinyjs::hide(id = "commentBox2")
      shinyjs::hide(id = "commentBox3")
      shinyjs::hide(id = "commentBox5")
      shinyjs::show(id = "commentBox4")
      # Histogram of the comment and replies made per week
      output$commentsRepliesWeekBar <- renderChart2({
        chartDependency()
        
        withProgress(message = "Processing",{
          
          #comment data for the selected course
          isolate({runChooserComments <- input$runChooserComments})
          cData <- comments_data[[which(names(comments_data) == runChooserComments)]]
          
          
          #checks to see if the table data used to compute the data for the chart is empty or not
          #if not, it displays the chart, if yes it shows an error message
          if(nrow(cData)!=0){
            plotData <- getCommentsBarChartWeek(cData)
            
            histogram <- Highcharts$new()
            histogram$chart(type = "column" , width = 550)
            histogram$data(plotData[,c("reply","post")])
            histogram$xAxis (categories = plotData$week_number, title = list(text = "Week"))
            histogram$yAxis(title = list(text = "Frequency"))
            histogram$title(text = runChooserComments)
            histogram$plotOptions (
              column = list(
                stacking = "normal"
              ),
              animation = FALSE
            )
            return(histogram)
          } else {
            shiny::validate(
              need(nrow(cData)>0,
                   "No data available"))
          }
        })
      })
    }
    else if (isolate(input$commentovervewGraph) == "NumberofCommentorsbyWeek") {
      shinyjs::hide(id = "commentBox1")
      shinyjs::hide(id = "commentBox2")
      shinyjs::hide(id = "commentBox3")
      shinyjs::hide(id = "commentBox4")
      shinyjs::show(id = "commentBox5")
      # Histogram of the number of authors per week
      output$authorsWeekBar <- renderChart2({
        chartDependency()

        withProgress(message = "Processing",{
          
          #get comment data for the selected course run
          isolate({runChooserComments <- input$runChooserComments})
          cData <- comments_data[[which(names(comments_data)==runChooserComments)]]
          
          #checks if the table needed for getting chart data is empty or not
          #if not empty, it computes the chart, else it throws an error message
          if(nrow(cData)!=0){
            plotData <- getNumberOfAuthorsByWeek(cData)
            histogram <- Highcharts$new()
            histogram$chart(type = "column" , width = 550)
            histogram$data(plotData[,c("authors")])
            histogram$xAxis (categories = plotData$week_number, title = list(text = "Week"))
            histogram$yAxis(title = list(text = "Frequency"))
            histogram$title(text = runChooserComments)
            histogram$plotOptions (
              column = list(
                stacking = "normal"
              ),
              animation = FALSE
            )
            return(histogram)
          } else {
            shiny::validate(
              need(nrow(cData)>0,
                   "No data available"))
          }
        })
      })
    }
  })
  
  
  output$totalMeasuresRunSelector <- renderUI({
    chartDependency()
    runs <- paste(input$course1,strsplit(input$run1," - ")[[1]][1], sep = " - ")
    if(input$run2 != "None"){
      runs <- c(runs, paste(input$course2,strsplit(input$run2," - ")[[1]][1], sep = " - "))
    }
    if(input$run3 != "None"){
      runs <- c(runs, paste(input$course3,strsplit(input$run3," - ")[[1]][1], sep = " - "))
    }
    if(input$run4 != "None"){
      runs <- c(runs, paste(input$course4,strsplit(input$run4," - ")[[1]][1], sep = " - "))
    }
    print(selectInput("totalMeasuresRunChooser", label = "Run",
                      choices = runs, width = "550px"))
  })
  
  # Line chart of the average number of comments made per step completion percentage
  output$avgCommentsCompletionLine <- renderChart2({
    # Draw the chart when the "chooseCourseButton" is pressed by the user
    chartDependency()
    measuresDependancy()
    
    withProgress(message = "Processing...",{
    
    # Get number of comments made and steps completed by learner
    learners <- unlist(strsplit(input$filteredLearners, "[,]"))
    
    # JSR replaced
    #assign("startDate", input$courseDates[1], envir = .GlobalEnv)
    #assign("endDate", input$courseDates[2], envir = .GlobalEnv)
    
    #gets the comment and step data for the selected course run
    cData <- comments_data[[which(names(comments_data)==input$totalMeasuresRunChooser)]]
    sData <- step_data[[which(names(step_data)==input$totalMeasuresRunChooser)]]
    
    #checks if the table needed to compute the data for the chart is empty or not
    #if not, it renders the chart, if empty it shows an error message
    if(nrow(cData)>0 && nrow(sData)>0) {
      comments <- getNumberOfCommentsByLearner(cData)
      steps <- getStepsCompleted(sData)
      # Round the percentage 
      steps$completed <- round(steps$completed)
      # Merge the two data frame together
      plotData <- merge(comments, steps, by = "learner_id")
      assign("plotTest", plotData, envir = .GlobalEnv)
      # To reduce the number of drawn point, scale the percentages to increments of 5
      plotData$completed <- lapply(plotData$completed, function (x) if (x %% 5 != 0) {x - x %% 5} else {x})
      plotData$completed <- as.numeric(plotData$completed)
      # Aggregate the data to get the total average of comments made per percentage of completed steps
      plotData <- ddply(plotData, ~completed, summarise, comments = mean(comments))
      # Create the line chart and pass in some options
      lineChart <- Highcharts$new()
      lineChart$chart (type = "line", width = 1200, height = 600)
      lineChart$series (
        name = "Comments",
        data = toJSONArray2(plotData, json = FALSE, names = FALSE),
        type = "line"
      )
      lineChart$xAxis (title = list(text = "Completed (%)"))
      lineChart$yAxis (title = list(text = "Comments"))
      return (lineChart)
    } else {
      shiny::validate(
        need(nrow(cData)>0 && nrow(sData)>0,
             "No data available")
      )
    }
    
  })
    
})
  
  #END: CHARTS - COMMENTS ORIENTATED
  
  # START COMMENTS TYPE ANALYSIS
  
  #to populate the drop down with the selected course runs
  output$runSelectorCommentsType <- renderUI({
    chartDependency()
    
    runs <- paste(input$course1,strsplit(input$run1," - ")[[1]][1], sep = " - ")
    if(input$run2 != "None"){
      runs <- c(runs, paste(input$course2,strsplit(input$run2," - ")[[1]][1], sep = " - "))
    }
    
    if(input$run3 != "None"){
      runs <- c(runs, paste(input$course3,strsplit(input$run3," - ")[[1]][1], sep = " - "))
    }
    
    if(input$run4 != "None"){
      runs <- c(runs, paste(input$course4,strsplit(input$run4," - ")[[1]][1], sep = " - "))
    }
    print(selectInput("runChooserCommentsType", label = "Run", choices = runs, width = "550px"))
  })
  
  #events to happen if the button is pressed
  observeEvent(input$runSelectorCommentsTypeButton, {
 
    if (isolate(input$commentTypeOutput) == "NumberAndTypeOfCommentsByStep") {
      
      shinyjs::show(id = "commentTypeBox2")
      shinyjs::hide(id = "commentTypeBox1")
      shinyjs::hide(id = "commentTypeBox3")
      shinyjs::hide(id = "commentTypeBox4")
      
      output$commentsTypeBarChart <- renderChart2({
        
        #to update if the go button is pressed or the comment selector is changed
        chartDependency()
        
        withProgress(message = "Processing comments", {
          
          #step and comment data for the selected course run
          isolate({runChooserCommentsType <- input$runChooserCommentsType})
          sData <- step_data[[which(names(step_data) == runChooserCommentsType)]]
          cData <- comments_data[[which(names(comments_data)== runChooserCommentsType)]]
          
          
          #checking to see if the data needed to compute the chart is empty or not
          #if empty it displays an error message, if not it renders the chart
          if(nrow(sData)>0 && nrow(cData)>0){
            
            #the data to be used in the chart
            plotData <- getCommentsTypeBarChart(sData,cData)
            
            #plotting the chart
            histogram <- Highcharts$new()
            histogram$chart(type = "column" , width = 1200)
            histogram$data(plotData[,c("lone post","initiating post", "first reply", "further reply", "initiator's reply")])
            histogram$xAxis (categories = plotData$week_step, title = list(text = "Activity step"))
            histogram$yAxis(title = list(text = "Frequency"))
            histogram$title(text = runChooserCommentsType)
            histogram$plotOptions (
              column = list(
                stacking = "normal"
              ),
              animation = FALSE
            )
            return(histogram)
          } else {
            shiny::validate(
              need(nrow(sData)>0 && nrow(cData)>0,
                   "No data available"))
          }
        })
      })
    } else if (isolate(input$commentTypeOutput) == "NumberAndTypeOfCommentsByDay"){
      shinyjs::show(id = "commentTypeBox3")
      shinyjs::hide(id = "commentTypeBox1")
      shinyjs::hide(id = "commentTypeBox2")
      shinyjs::hide(id = "commentTypeBox4")
      
      output$commentsTypeLineChart <- renderChart2({ 
        #to update if the go button is pressed 
        chartDependency()
        
        withProgress(message = "Processing comments", {
          
          #step and comment data for the selected course run
          isolate({runChooserCommentsType <- input$runChooserCommentsType})
          cData <- comments_data[[which(names(comments_data)==runChooserCommentsType)]]
          
          #checking to see if the data needed to compute the chart is empty or not
          #if empty it displays an error message, if not it renders the chart
          if(nrow(cData)>0){
            
            #getting the data for the plot
            plotData <- getCommentsTypeNumberByDate(cData)
            
            #plotting the chart
            histogram <- Highcharts$new()
            histogram$chart(type = "line" , width = 1200)
            histogram$data(plotData[,c("lone post","initiating post", "first reply", "further reply", "initiator's reply")])
            histogram$xAxis (categories = as.character(plotData$date), title = list(text = "Date"))
            histogram$yAxis(title = list(text = "Frequency"))
            histogram$title(text = runChooserCommentsType)
            histogram$plotOptions (
              column = list(
                stacking = "normal"
              ),
              animation = FALSE
            )
            return(histogram)
          } else {
            shiny::validate(
              need(nrow(sData)>0 && nrow(cData)>0,
                   "No data available"))
          }
        })
      })
      
    } else if (isolate(input$commentTypeOutput) == "CommentsAnalysisTable") {
      shinyjs::show(id = "commentTypeBox1")
      shinyjs::hide(id = "commentTypeBox2")
      shinyjs::hide(id = "commentTypeBox3")
      shinyjs::hide(id = "commentTypeBox4")
      
      output$commentAnalysisTable <- renderDataTable({
        
        #to update if the go button is pressed or the comment selector is changed
        chartDependency()
        
        withProgress(message = "Processing Comments",{
          #using isolate not to update the table when changing the value in the drop down
          isolate({runChooserCommentsType <- input$runChooserCommentsType})
          
          #data frame to be used in the tables
          dataf <- getCommentTypeAnalysisData(comments_data, runChooserCommentsType, courseMetaData)
          
          DT::datatable(
            caption = runChooserCommentsType,
            dataf[,c("timestamp","week_step","text","nature", "thread","mentor", "type", "likes","url")], class = 'cell-border stripe', filter = 'top', extensions = 'Buttons',
            colnames = c(
              "Date" = 1,
              "Step" = 2,
              "Comment" = 3,
              "Comment Category" = 4,
              "Part of a Thread?" = 5,
              "Mentor intervened in the thread?" = 6,
              "Learner type" = 7,
              "Likes" = 8,
              "Link" = 9
            ),
            options = list(
              autoWidth = TRUE,
              columnDefs = list(list(width = '8%', targets = list(0,1,3,4,5,6,7,8))),
              scrollY = "700px",
              lengthMenu = list(c(10,20,30, -1),c('10','20','30', 'All')),
              pageLength = 20,
              dom = 'lfrtBip',
              buttons = list(
                "print"
              )
            ),
            rownames = FALSE,
            selection = 'single',
            escape = FALSE
          )
        })
      })
      
      #download button for the comments analysis data - as a csv file
      output$downloadCommentAnalysis <- downloadHandler(
        
        filename = function() { paste("comment_analysis", '.csv', sep='') },
        content = function(file) {
          dataf <- getCommentTypeAnalysisData(comments_data, input$runChooserCommentsType, courseMetaData)
          write.csv(dataf, file)
        }
      )
    } else if(isolate(input$commentTypeOutput) == "CommentsByCategory"){
      shinyjs::show(id = "commentTypeBox4")
      shinyjs::hide(id = "commentTypeBox1")
      shinyjs::hide(id = "commentTypeBox2")
      shinyjs::hide(id = "commentTypeBox3")
      
      output$commentsByCategory <- renderPlotly({
        
        #to update if the go button is pressed 
        chartDependency()
        
        withProgress(message = "Processing",{
          isolate({runChooserCommentsType <- input$runChooserCommentsType})
          
          #getting the data used in the plot
          data <- getCommentTypeAnalysisData(comments_data, runChooserCommentsType, courseMetaData)
          
          #counting the number of elements in each category
          categorisation <- count(data$nature)
          
          #defining the colors and plotting the graph
          colors <- c('rgb(211,94,96)','rgb(128,133,133)', 'rgb(144, 103, 167)', 'rgb(171, 104, 87)','rgb(0,102,204)',  'rgb(1114, 147, 203)', 'rgb(0, 153, 76)')
          plot_ly(categorisation, labels = ~x, values = ~freq, type = 'pie',
                  textposition = 'inside',
                  textinfo = 'label+percent',
                  insidetextfont = list(color = '#FFFFFF'),
                  hoverinfo = 'text',
                  text = ~paste(x, ': ', freq, 'comments'),
                  marker = list(colors = colors,
                                line = list(color = '#FFFFFF', width = 1)),
                  #The 'pull' attribute can also be used to create space between the sectors
                  showlegend = FALSE) %>%
            layout(title = runChooserCommentsType,
                   xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                   yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))%>%
            config(displayModeBar = F)
          
          
        })
      })
    }
  })
  
  # END COMMENTS TYPE ANALYSIS
  
  
  
  
  # START COMMENT VIEWER TAB
  
  #Selector to choose which run to view comments of
  output$commentRunSelector <- renderUI({
    chartDependency()
    runs <- paste(input$course1,strsplit(input$run1," - ")[[1]][1], sep = " - ")
    if(input$run2 != "None"){
      runs <- c(runs, paste(input$course2,strsplit(input$run2," - ")[[1]][1], sep = " - "))
    }
    if(input$run3 != "None"){
      runs <- c(runs, paste(input$course3,strsplit(input$run3," - ")[[1]][1], sep = " - "))
    }
    if(input$run4 != "None"){
      runs <- c(runs, paste(input$course4,strsplit(input$run4," - ")[[1]][1], sep = " - "))
    }
    print(selectInput("runChooser", label = "Run", choices = runs, width = "550px"))
  })
  
  # View comments button
  output$viewButton <- renderUI({
    chartDependency()
    print(actionButton("viewButton","View Comments"))
  })
  
  # Load cloud button
  output$loadCloud <- renderUI({
    chartDependency()
    print(actionButton("loadCloud", "Load Cloud"))
  })
  
  c_data <- NULL
  
  # Dependency for the data table to only load after the view comments button has been pressed
  viewPressed <- eventReactive(input$viewButton, {
    data <- getCommentViewerData(comments_data, input$runChooser, courseMetaData)
    c_data <<- data
    return(input$runChooser)
  })
  
  
  # Produces a data table for the comments
  output$commentViewer <- renderDataTable({
    chartDependency()
    viewPressed()
    if(input$viewButton == 0){
      return()
    }
    withProgress(message = "Processing Comments",{
      data <- c_data
      isolate({runChooser <- input$runChooser})
      DT::datatable(
        caption = runChooser,
        data[,c("timestamp","week_step","text","thread","likes","url")], class = 'cell-border stripe', filter = 'top', extensions = 'Buttons',
        colnames = c(
          "Date" = 1,
          "Step" = 2,
          "Comment" = 3,
          "Part of a Thread?" = 4,
          "Likes" = 5,
          "Link" = 6
        ),
        options = list(
          autoWidth = TRUE,
          columnDefs = list(list(width = '10%', targets = list(0,1,3,4,5))),
          scrollY = "700px",
          lengthMenu = list(c(10,20,30, -1),c('10','20','30', 'All')),
          pageLength = 20,
          dom = 'lfrtBip',
          buttons = list(
            "print"
          )
        ),
        rownames = FALSE,
        selection = 'single',
        escape = FALSE
      )
    })
  })
  
  #download button for comments viewer data - as a csv file
  output$downloadCommentViewer <- downloadHandler(
    filename = function() { paste("comments_viewer", '.csv', sep='') },
    content = function(file) {
      data <- c_data
      write.csv(data, file)
    }
  )
  
  # Checks if a comment has been selected
  threadSelected <- eventReactive( input$commentViewer_rows_selected, {
    runif(input$commentViewer_rows_selected)
  })
  
  #Produced a data table of the thread for the comment selected
  output$threadViewer <- renderDataTable({
    chartDependency()
    viewPressed()
    threadSelected()
    withProgress(message = "Retrieving Thread",{
      #data <- getCommentViewerData(comments_data, viewPressed(),courseMetaData)
      data <- c_data
      data$likes <- as.integer(data$likes)
      selectedRow <- data[input$commentViewer_rows_selected,]
      if(selectedRow$thread != "Yes"){
        return()
      }
      
      reply = TRUE
      parent = FALSE
      if(selectedRow$parent_id == 0){
        reply = FALSE
        parent = TRUE
      }
      
      if(parent){
        rows <- data[c(which(data$id == selectedRow$id), which(data$parent_id == selectedRow$id)),]
      } else {
        rows <- data[c(which(data$id == selectedRow$parent_id), which(data$parent_id == selectedRow$parent_id),  which(data$id == selectedRow$id)),]
      }
      
      rows <- rows[order(rows$timestamp),]
      isolate({runChooser <- input$runChooser})
      DT::datatable(
       caption = runChooser,
        rows[,c("timestamp","week_step","text","likes","url")], class = 'cell-border stripe', filter = 'top', extensions = 'Buttons',
        colnames = c(
          "Date" = 1,
          "Step" = 2,
          "Comment" = 3,
          "Likes" = 4,
          "Link" = 5
        ),
        options = list(
          autoWidth = TRUE,
          columnDefs = list(list(width = '10%', targets = list(0,1,3,4))),
          scrollY = "700px",
          lengthMenu = list(c(10,20,30, -1),c('10','20','30', 'All')),
          pageLength = 20,
          dom = 'lfrtBip',
          buttons = list(
            "print"
          )
        ),
        rownames = FALSE,
        selection = 'single',
        escape = FALSE
      )
    })
  })
  
  #download button for thread viewer data - as a csv file
  output$downloadThreadViewer <- downloadHandler(
    filename = function() { paste("thread_viewer", '.csv', sep='') },
    content = function(file) {
      data <- c_data
      data$likes <- as.integer(data$likes)
      selectedRow <- data[input$commentViewer_rows_selected,]
      if(selectedRow$thread != "Yes"){
        return()
      }
      
      reply = TRUE
      parent = FALSE
      if(selectedRow$parent_id == 0){
        reply = FALSE
        parent = TRUE
      }
      
      if(parent){
        rows <- data[c(which(data$id == selectedRow$id), which(data$parent_id == selectedRow$id)),]
      } else {
        rows <- data[c(which(data$id == selectedRow$parent_id), which(data$parent_id == selectedRow$parent_id),  which(data$id == selectedRow$id)),]
      }
      
      rows <- rows[order(rows$timestamp),]
      write.csv(rows, file)
    }
  )
  
  #Makes the wordcloud code repeatable.
  wordcloud_rep <- repeatable(wordcloud)
  
  #Generates the terms for the word cloud
  terms <- reactive({
    isolate({
      withProgress(message = "Processing Word Cloud",{
        data <- comments_data[[which(names(comments_data) == input$runChooser)]]
        data$week_step <- getWeekStep(data)
        data <- data[c("text","likes")]
        data$likes <- as.numeric(data$likes)
        data <- data[order(-data$likes),]
        text <- unlist(strsplit(toString(data$text),"[\n]"))
        myCorpus = Corpus(VectorSource(head(text,1000)))
        myCorpus = tm_map(myCorpus, content_transformer(tolower))
        myCorpus = tm_map(myCorpus, removePunctuation)
        myCorpus = tm_map(myCorpus, removeNumbers)
        myCorpus = tm_map(myCorpus, removeWords,
                          c(stopwords("SMART")))
        myDTM = TermDocumentMatrix(myCorpus,
                                   control = list(minWordLength = 1))
        m <- as.matrix(myDTM)
        m <- sort(rowSums(m), decreasing = TRUE)
      })
    })
  })
  
  #Cloud depends on having pushed the load cloud button
  cloudDependancy <- eventReactive(input$loadCloud, {})
  
  #Produced the word cloud
  output$stepWordCloud <- renderPlot({
    chartDependency()
    cloudDependancy()
    m <- terms()
    wordcloud_rep(names(m),m,scale = c(4,0.5),
                  min.freq = input$commentCloudFreq,
                  max.words = input$commentCloudMax,
                  colors = brewer.pal(8,"Dark2"),
                  rot.per = 0)
  })
  
  # END COMMENT VIEWER TAB
  
  
  
  
  # START LEARNERS ANALYSIS TAB
  
  #Selector to choose which run to view learners of
  output$learnersRunSelector <- renderUI({
    chartDependency()
    runs <- paste(input$course1,strsplit(input$run1," - ")[[1]][1], sep = " - ")
    if(input$run2 != "None"){
      runs <- c(runs, paste(input$course2,strsplit(input$run2," - ")[[1]][1], sep = " - "))
    }
    if(input$run3 != "None"){
      runs <- c(runs, paste(input$course3,strsplit(input$run3," - ")[[1]][1], sep = " - "))
    }
    if(input$run4 != "None"){
      runs <- c(runs, paste(input$course4,strsplit(input$run4," - ")[[1]][1], sep = " - "))
    }
    print(selectInput("runChooserLearners", label = "Run", choices = runs, width = "550px"))
  })
  
  
  # View learners button
  output$viewLearnersButton <- renderUI({
    chartDependency()
    print(actionButton("viewLearnersButton","View analysis"))
  })
  
  #creating a global variable to store the data so that loading will be faster
  s_data <- NULL
  
  #Dependency for the pie chart and data table to only load after the view learners button has been pressed
  
  viewPressedLearners <- eventReactive(input$viewLearnersButton,{
    
    comments <- comments_data[[which(names(comments_data) == input$runChooserLearners)]]
    data <- getCommentsForClassification(comments)
    df <- getLearnerClassificationData(data)
    
    s_data <<- df
    
    return(input$runChooserLearners)
  })
  
  #Create a pie chart to display percentages for different types of learners
  output$learnersByCategory <- renderPlotly({
    chartDependency()
    viewPressedLearners()
    
    df <- s_data
    
    category <- count(df$type)
    
    isolate({runChooserLearners = input$runChooserLearners})
    
    colors <- c('rgb(211,94,96)','rgb(128,133,133)', 'rgb(144, 103, 167)', 'rgb(171, 104, 87)','rgb(0,102,204)',  'rgb(1114, 147, 203)', 'rgb(0, 153, 76)')
    plot_ly(category, labels = ~x, values = ~freq, type = 'pie',
            textposition = 'inside',
            textinfo = 'label+percent',
            insidetextfont = list (color = '#FFFFFF'),
            hoverinfo = 'text',
            text = ~paste(x, ': ', freq, 'learners'),
            marker = list(colors = colors,
                          line = list(color = '#FFFFFF', width = 1)),
            showlegend = FALSE) %>%
      layout(title = runChooserLearners,
             xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
             yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))%>%
      config(displayModeBar = F)
    
  })
  
  #Produce a data table for learners' activity
  output$learnerActivityViewer <- renderDataTable({
    chartDependency()
    viewPressedLearners()
    if(input$viewLearnersButton == 0){
      return()
    }
    
    isolate({runChooserLearners = input$runChooserLearners})
    
    withProgress(message = "Processing Learners' List",{
      
      df <- s_data
      
      DT::datatable(
        caption = runChooserLearners,
        df[, c("learner_id", "initiating.post", "lone.post", "first.reply", "initiator.reply", "further.reply", "sumofcommentsmade", "replies.received", "likes", "type")], class = 'cell-border stripe', filter = 'top', extensions = 'Buttons',
        colnames = c(
          "Learner ID" = 1,
          "Initiating Posts" = 2,
          "Lone Posts" = 3,
          "First Replies" = 4,
          "Initiator's Replies" = 5,
          "Further Replies" = 6,
          "Total" = 7,
          "Replies Received" = 8,
          "Likes Received" = 9,
          "Type of Learner" = 10
        ),
        options = list(
          autoWidth = TRUE,
          columnDefs = list(list(width = '10%', targets = list(0,1,2,3,4,5,6,7,8,9))),
          scrollY = "700px",
          lengthMenu = list(c(10, 20, 30, -1), c('10', '20', '30', 'All' )),
          pageLength = 20,
          dom = 'lfrtBip',
          buttons = list(
            "print"
          )
        ),
        rownames = FALSE,
        selection = 'single',
        escape = FALSE
      )
    })
  })
  
  #download button for learners activity data - as a csv file
  output$downloadLearnersActivity <- downloadHandler(
    filename = function() { paste("learners_analysis", '.csv', sep='') },
    content = function(file) {
      df <- s_data
      write.csv(df, file)
    }
  )
  
  # Checks if a comment has been selected
  commentsLearnerSelected <- eventReactive( input$learnerActivityViewer_rows_selected, {
    runif(input$learnerActivityViewer_rows_selected)
  })
  
  #Produce a data table of the comments contributed by one particular learner
  output$commentLearnersAnalysisViewer <- renderDataTable({
    chartDependency()
    viewPressedLearners()
    commentsLearnerSelected()
    
    withProgress(message = "Retrieving comments",{
      isolate({runChooserLearners = input$runChooserLearners})
      
      df <- s_data
      
      #getting the data for the table - the comments of the selected learner
      comments <- getCommentLearnersAnalysisViewerData(comments_data, input$runChooserLearners, courseMetaData)
      selectedRow <- df[input$learnerActivityViewer_rows_selected,]
      comments <- comments[comments$learner_id ==  selectedRow$learner_id, ]
      
      DT::datatable(
        caption = runChooserLearners,
        comments[,c("timestamp", "step", "week_number", "text", "nature", "likes","url")], class = 'cell-border stripe', filter = 'top', extensions = 'Buttons',
        colnames = c(
          "Date" = 1,
          "Step" = 2,
          "Week" = 3,
          "Comment" = 4,
          "Comment Category" = 5,
          "Likes" = 6,
          "Link" = 7
        ),
        options = list(
          autoWidth = TRUE,
          scrollY = "700px",
          lengthMenu = list(c(10,20,30, -1),c('10','20','30', 'All')),
          pageLength = 20,
          dom = 'lfrtBip',
          buttons = list(
            "print" 
          )
        ),
        rownames = FALSE,
        selection = 'single',
        escape = FALSE
      )
    })
  })
  
  #download button for comments contributed data - as a csv file
  output$downloadCommentsContributed <- downloadHandler(
    filename = function() { paste("comments_contributed", '.csv', sep='') },
    content = function(file) {
      df <- s_data
      
      comments <- getCommentLearnersAnalysisViewerData(comments_data, input$runChooserLearners, courseMetaData)
      selectedRow <- df[input$learnerActivityViewer_rows_selected,]
      comments <- comments[comments$learner_id ==  selectedRow$learner_id, ]
      
      write.csv(comments, file)
    }
  )
  
  # END LEARNERS ANALYSIS TAB
  
  
  
  # START TEAM MEMBERS TAB
  
  #Selector to choose which run to be displayed
  output$memberSelector <- renderUI({
    chartDependency()
    runs <- paste(input$course1,strsplit(input$run1," - ")[[1]][1], sep = " - ")
    if(input$run2 != "None"){
      runs <- c(runs, paste(input$course2,strsplit(input$run2," - ")[[1]][1], sep = " - "))
    }
    if(input$run3 != "None"){
      runs <- c(runs, paste(input$course3,strsplit(input$run3," - ")[[1]][1], sep = " - "))
    }
    if(input$run4 != "None"){
      runs <- c(runs, paste(input$course4,strsplit(input$run4," - ")[[1]][1], sep = " - "))
    }
    print(selectInput("runChooserTeam", label = "Run", choices = runs, width = "550px"))
  })
  
  # View team members button
  output$viewTeamButton <- renderUI({
    chartDependency()
    print(actionButton("viewTeamButton","View Team Members"))
  })
  
  # Dependency for the data table to only load after the view team members button has been pressed
  viewTeamPressed <- eventReactive(input$viewTeamButton, {
    return(input$runChooserTeam)
  })
  
  # Produces a data table for the team members
  output$teamMembersViewer <- renderDataTable({
    chartDependency()
    viewTeamPressed()
    if(input$viewTeamButton == 0){
      return()
    }
    withProgress(message = "Processing",{
      isolate({runChooserTeam = input$runChooserTeam})
      data <- getTeamMembersData(team_data, comments_data, viewTeamPressed(), courseMetaData)
      DT::datatable(
        caption = runChooserTeam,
        data[,c("name","timestamp","week_step","text", "url")], class = 'cell-border stripe', filter = 'top', extensions = 'Buttons',
        colnames = c(
          "Name" = 1,
          "Date" = 2,
          "Step" = 3,
          "Comment" = 4,
          "Link" = 5
        ),
        options = list(
          autoWidth = TRUE,
          columnDefs = list(list(width = '10%', targets = list(0,1,2))),
          scrollY = "700px",
          lengthMenu = list(c(10,20,30, -1),c('10','20','30', 'All')),
          pageLength = 20,
          dom = 'lfrtBip',
          buttons = list(
            "print"
          )
        ),
        rownames = FALSE,
        selection = 'single',
        escape = FALSE
      )
    })
  })
  
  #download button for team members data - as a csv file
  output$downloadTeamMembers <- downloadHandler(
    filename = function() { paste("team_members", '.csv', sep='') },
    content = function(file) {
      
      data <- getTeamMembersData(team_data, comments_data, viewTeamPressed(), courseMetaData)
      write.csv(data, file)
    }
  )
  
  
  # Checks if a comment has been selected
  threadSelected <- eventReactive( input$commentViewer_rows_selected, {
    runif(input$commentViewer_rows_selected)
  })
  
  # END TEAM MEMBERS TAB
  
  
  
  # START SURVEYS ANALYSIS TAB
  
  #Selector to choose which run to be displayed
  output$surveyRunSelector <- renderUI({
    chartDependency()
    runs <- paste(input$course1,strsplit(input$run1," - ")[[1]][1], sep = " - ")
    if(input$run2 != "None"){
      runs <- c(runs, paste(input$course2,strsplit(input$run2," - ")[[1]][1], sep = " - "))
    }
    if(input$run3 != "None"){
      runs <- c(runs, paste(input$course3,strsplit(input$run3," - ")[[1]][1], sep = " - "))
    }
    if(input$run4 != "None"){
      runs <- c(runs, paste(input$course4,strsplit(input$run4," - ")[[1]][1], sep = " - "))
    }
    print(selectInput("runChooserSurvey", label = "Run", choices = runs, width = "550px"))
  })
  
  #View surveys analysis button
  output$viewSurAnButton <- renderUI({
    chartDependency()
    print(actionButton("viewSurAnButton", "View Survey"))
  })
  
  #Dependency for the data tables to only load after the view surveys analysis button has been pressed
  viewSurAnPressed <- eventReactive(input$viewSurAnButton, {
    return(input$runChooserSurvey)
  })
  
  #reactive to return the uploaded file
  preCourseSurveyChosen <- eventReactive(input$fileChooserSurveyPre, {
    return(input$fileChooserSurveyPre)
  })
  
  
  #Produce a table for the pre course survey analysis and the comment in step 1.2
  output$surveyAnalysisTable <- renderDataTable({
    
    #updating the table when the choose course or view buttons are pressed 
    chartDependency()
    viewSurAnPressed()
    if(input$viewSurAnButton == 0){
      return()
    }
    
    #the chosen csv or xls file
    #if it's not of the right format it shows an error message
    preCourseSurveyFile <- preCourseSurveyChosen()
    if(file_ext(preCourseSurveyFile)!="csv" && file_ext(preCourseSurveyFile)!="xls"){
      shiny::validate(
        need(file_ext(preCourseSurveyFile)=="csv" || file_ext(preCourseSurveyFile)=="xls",
             "Please choose a corresponding csv or xls file")
      )
      return()
    }
    withProgress(message = "Processing...",{
      
      #data frame with comment data for the selected course run
      isolate({runChooserSurvey = input$runChooserSurvey})
      comments <- comments_data[[which(names(comments_data) == runChooserSurvey)]]
      
      #reading in the data and the header details (double header) for the csv or xls files
      if(file_ext(preCourseSurveyFile)=="csv"){
        dfPreCourse <- read.csv(preCourseSurveyFile$datapath, header = TRUE)
        headerPreCourse <- read.csv(preCourseSurveyFile$datapath, nrows = 2, header = FALSE)
      } else if (file_ext(preCourseSurveyFile)=="xls"){
        dfPreCourse <- read.xls(preCourseSurveyFile$datapath, sheet = "Sheet1", blank.lines.skip = FALSE, header = TRUE, skipNul = TRUE)
        headerPreCourse <- read.xls(preCourseSurveyFile$datapath, sheet = "Sheet1", blank.lines.skip = FALSE, nrows = 2, header = FALSE, skipNul = TRUE)
      }
      
      #combining the 2 rows in the header into a single row and assigning the new header to the data
      header <- character(ncol(headerPreCourse))
      for(i in 1:ncol(headerPreCourse)){
        header[i] <- paste(headerPreCourse[1,i], headerPreCourse[2,i], sep = " ")
        
      }
      names(dfPreCourse) <- header
      
      #getting the table data and creating the table
      data <- getBasicSurveyData(dfPreCourse, comments)
      
      DT::datatable(
        caption = runChooserSurvey,
        data, class = 'cell-border stripe', filter = 'top', extensions = 'Buttons',
        options = list(
          autoWidth = TRUE,
          columnDefs = list(list(width = '300px', targets = list(1)), list(width = '150px', targets = "_all")),
          scrollY = "850px",
          scrollX = TRUE,
          lenghtMenu = c(10,20,30),
          pageLenght = 20,
          dom = 'lfrtBip',
          buttons = list(
            "print"
          )
        ),
        rownames = FALSE,
        selection = 'single',
        escape = FALSE
      )
    })
  })
  
  #download button for the survey analysis data - as a csv file
  output$downloadSurveyAnalysis <- downloadHandler(
    
    filename = function() { paste("survey_analysis", '.csv', sep='') },
    content = function(file) {
      preCourseSurveyFile <- preCourseSurveyChosen()
      
      #data frame with comment data for the selected course run
      comments <- comments_data[[which(names(comments_data) == input$runChooserSurvey)]]
      
      #reading in the data and the header details (double header) for the csv or xls files
      if(file_ext(preCourseSurveyFile)=="csv"){
        dfPreCourse <- read.csv(preCourseSurveyFile$datapath, header = TRUE)
        headerPreCourse <- read.csv(preCourseSurveyFile$datapath, nrows = 2, header = FALSE)
      } else if (file_ext(preCourseSurveyFile)=="xls"){
        dfPreCourse <- read.xls(preCourseSurveyFile$datapath, sheet = "Sheet1", blank.lines.skip = FALSE, header = TRUE, skipNul = TRUE)
        headerPreCourse <- read.xls(preCourseSurveyFile$datapath, sheet = "Sheet1", blank.lines.skip = FALSE, nrows = 2, header = FALSE, skipNul = TRUE)
      }
      #combining the 2 rows in the header into a single row and assigning the new header to the data
      header <- character(ncol(headerPreCourse))
      for(i in 1:ncol(headerPreCourse)){
        header[i] <- paste(headerPreCourse[1,i], headerPreCourse[2,i], sep = " ")
        
      }
      names(dfPreCourse) <- header
      
      #getting the table data 
      data <- getBasicSurveyData(dfPreCourse, comments)
      write.csv(data, file)
    }
  )
  
  # END SURVEY ANALYSIS TAB
  
  
  
  #START LEARNER PATHS TAB

    #populate the drop down with the selected course runs
    output$runPathSelector <- renderUI({
      chartDependency()
      
      isolate({runs <- paste(input$course1,strsplit(input$run1," - ")[[1]][1], sep = " - ")
      if(input$run2 != "None"){
        runs <- c(runs, paste(input$course2,strsplit(input$run2," - ")[[1]][1], sep = " - "))
      }
      if(input$run3 != "None"){
        runs <- c(runs, paste(input$course3,strsplit(input$run3," - ")[[1]][1], sep = " - "))
      }
      if(input$run4 != "None"){
        runs <- c(runs, paste(input$course4,strsplit(input$run4," - ")[[1]][1], sep = " - "))
      }})
      
      print(selectInput("runPathSelector", label = "Run", choices = runs, width = "550px"))
    })
    
    optionPathSelectorDependency <- eventReactive(input$optionPathSelector, {})
    
    #populate the drop down of the week selector for the selected course run
    output$weekPathSelector <- renderUI({
      chartDependency()
      optionPathSelectorDependency()
      if(input$optionPathSelector == "LearnersPathsByCourseWeek"){
        cData <- course_data[[which(names(course_data) == input$runPathSelector)]]
        noOfWeeks <- cData[1, "no_of_weeks"]
        weeks <- seq.int(noOfWeeks)
        print(selectInput("weekPathSelector", label = "Week of the course", choices = weeks, width = "550px"))
      }

    })
    
    #creating the button to create the sankey diagram
    output$viewLearnersPathButton <- renderUI({
      chartDependency()
      print(actionButton("viewLearnersPathButton","View paths"))
    })
    
    #for dependencies about the button for creating the learning path
    learnerPathButtonDependency <- eventReactive(input$viewLearnersPathButton, {})
    
    observeEvent(input$viewLearnersPathButton, {
      
      #creates two sankey diagrams - one for forward learning paths and one for backwards ones
      #contains start and end nodes, as well as nodes for each week of the course
      #it shows the number of learners that go from a week to another, as well the number of students that finish each week
      #and the number of students that begin the course each week
      if (isolate(input$optionPathSelector) == "LearnersPathsForWholeCourseByWeeks") {
        shinyjs::hide(id = "pathBox2")
        shinyjs::show(id = "pathBox1")
        
        #rendering some helfpul text above the diagram
        output$sankeyNotesCourse <- renderText({
          "Note: The diagram shows the number of students that go from one week to another. The start node indicates the number of learners that started the course at each particular week.
          The end node shows the number of learners that quit the course after each particular week."
        })
        
        withProgress(message = "Processing...",{ 
          #to re-create the diagram when pressing the button
          learnerPathButtonDependency()
          
          #getting the course and step data for the selected course run
          #using isolate to make sure the diagram updates only after pressing the button
          isolate({
            cData <- course_data[[which(names(course_data) == input$runPathSelector)]]
            sData <- step_data[[which(names(step_data) == input$runPathSelector)]]
          })
          
          #selecting the steps that are completed and ordering them by the date of completion (grouped by learner id)
          sData <- sData[!is.na(sData$last_completed_at), ]
          sData <- sData[order(sData$learner_id, sData$last_completed_at), ]
          fst <- sData$week_number[1]
          lst <- sData$week_number[nrow(sData)]
          
          #getting the number of weeks of the course run and creating the nodes' names
          noOfWeeks <- cData$no_of_weeks
          courseWeeks <- seq.int(from = 1, to = noOfWeeks, by = 1)
          weeks <- paste("week", courseWeeks, sep = "")
          
          #creating a first data frame to store values to be put in the sankey diagram
          #for the case when learners jump ahead or backtrack in the course
          m1 <- as.data.frame(matrix(0, ncol = noOfWeeks, nrow = noOfWeeks))
          colnames(m1) <- weeks
          rownames(m1) <- weeks
          
          #creating a second data frame to store values to be put in the sankey diagram
          #to compute the numbers of learners that start or end the course at a specific week 
          m2 <- as.data.frame(matrix(0, ncol = noOfWeeks, nrow = noOfWeeks))
          colnames(m2) <- weeks
          rownames(m2) <- weeks
          
          #an auxiliary data frame to remember if I counted a transition for a specific learner
          aux <- as.data.frame(matrix(0, ncol = noOfWeeks, nrow = noOfWeeks))
          colnames(aux) <- weeks
          rownames(aux) <- weeks
          
          #storing in 2 tables the number of students that go from a week to another 
          for(i in 1:(nrow(sData)-1)){
            
            #counting the number of learners that transit between weeks
            #using an auxiliary to make sure we don't count the same learner multiple times
            if(sData$learner_id[i] == sData$learner_id[i+1] && sData$week_number[i]!=sData$week_number[i+1]){
              if(aux[sData$week_number[i], sData$week_number[i+1]] == 0){
                m1[sData$week_number[i], sData$week_number[i+1]] <- m1[sData$week_number[i], sData$week_number[i+1]] + 1
                aux[sData$week_number[i], sData$week_number[i+1]] <- 1
              }
              
              #used to count the number of students that start or finish in a particular week
            } else if (sData$learner_id[i] != sData$learner_id[i+1]){
              aux[,] <- 0
              m2[sData$week_number[i], sData$week_number[i+1]] <- m2[sData$week_number[i], sData$week_number[i+1]] + 1
            }
          }
          
          #naming the nodes in the sankey diagram
          nodes <- data.frame("name" = "start", stringsAsFactors = FALSE)
          nodes <- rbind(nodes, data.frame("name" = weeks))
          nodes <- rbind(nodes, data.frame("name" = "end"))
          nodes$color <- colorRampPalette(c("aliceblue", "darkblue"))(nrow(nodes))
          #nodes$color <- palette()
          #creating the links data frame to create the links in the sankey diagram
          links <- data.frame("source" = numeric(), "target" = numeric(), "value" = numeric(), "type" = character(), "color" = character())
          
          #counting the number of students that start the course at each specific week (e.g. most of students start with week 1, but others start with weeks 2 or 3)
          for(j in 1:ncol(m2)){
            s <- 0
            for(i in 1:nrow(m2)){
              s <- s + m2[i,j]
            }
            if(j==fst){
              s <- s+1
            }
            if(s > 0){
              links <- rbind(links, data.frame("source" = 0, "target" = j, "value" = s, "type" = nodes[1, 1], "color" = nodes$color[1]))
            }
          }
          
          #populating the links data frame with the sources, targets and values from the table
          for(i in 1:(nrow(m1))){
            for(j in 1:(ncol(m1))){
              if(m1[i, j] > 0){
                links <- rbind(links, data.frame("source" = i, "target" = j, "value" = m1[i, j], "type" = nodes[i+1, 1], "color" = nodes$color[i+1]))
              }
            }
          }
          
          #counting the number of students that end the course at each specific week (e.g. some students quit after week 1, other remain till last week)
          for(i in 1:nrow(m2)){
            s <- 0
            for(j in 1:ncol(m2)){
              s <- s + m2[i,j]
            }
            if(i == lst){
              s <- s+1
            }
            if(s > 0){
              links <- rbind(links, data.frame("source" = i, "target" = nrow(nodes) - 1, "value" = s, "type" = nodes[i+1, 1], "color" = nodes$color[i+1]))
            }
          }
          
          links$type <- as.character(links$type)
          nodes$name <- as.character(nodes$name)
          
        })
        
        #rendering the diagram for the learner paths that are going forward
        output$sankeyLearnerPathsCourse <- renderPlotly({

          #isolating the links that are going forward
          links <- links[links$source < links$target, ]

          getSankeyDiagram("Learner paths going forward throughout the course", nodes, links)
            
        })
        
        #rendering the diagram for the backwards learning paths (learners that go from a week to a previous one e.g. week 3 to week 1)
        output$sankeyLearnerPathsCourseRev <- renderPlotly({
          
          #isolating the links that are going backwards
          links <- links[links$source >= links$target, ]
          
          getSankeyDiagram("Learner paths going backwards throughout course", nodes, links)
          
        })
        
        
      } else if (isolate(input$optionPathSelector) == "LearnersPathsByCourseWeek"){
          shinyjs::hide(id = "pathBox1")
          shinyjs::show(id = "pathBox2")
          
          output$sankeyNotesWeek <- renderText({
            "Note: The diagram shows the number of students that go from one step to another (judging by the dates when the steps were last marked as completed). For clarity, it only contains the links with value > 10. 
            The last node shows the number of students that went from a step to a different week or ended the course."
          })
          
          #to re-create the diagram when pressing the button
          learnerPathButtonDependency()
          
          withProgress(message = "Processing...",{ 
            #getting the course and step data for the selected course run
            #using isolate to make sure the diagram updates only after pressing the button
            isolate({
              cData <- course_data[[which(names(course_data) == input$runPathSelector)]]
              sData <- step_data[[which(names(step_data) == input$runPathSelector)]]
              
              #getting the step data for the selected week only
              sData <- sData[sData$week_number == input$weekPathSelector, ]
              sData$week_step <- getWeekStep(sData)
              sData <- sData[!is.na(sData$last_completed_at), ]
              
              sData <- sData[order(sData$learner_id, sData$last_completed_at), ]
            })
            
            #getting the unique steps visited in the selected week
            steps <- unique(sData$week_step)
            steps <- sort(steps)
            
            #creating a first data frame to store values to be put in the sankey diagram
            #for the case when learners jump ahead or backtrack within the same week
            m1 <- as.data.frame(matrix(0, ncol = length(steps), nrow = length(steps)))
            colnames(m1) <- steps
            rownames(m1) <- steps
            
            #creating a second data frame to store values to be put in the sankey diagram
            #for the case when learners jump to a diff week or end the course
            m2 <- as.data.frame(matrix(0, ncol = length(steps), nrow = length(steps)))
            colnames(m2) <- steps
            rownames(m2) <- steps
            
            #populating the table
            for(i in (1:(nrow(sData)-1))){
              if (sData$learner_id[i] == sData$learner_id[i+1]) {
                m1[sData$week_step[i], sData$week_step[i+1]] <- m1[sData$week_step[i], sData$week_step[i+1]] + 1
              } else {
                m2[sData$week_step[i], sData$week_step[i+1]] <- m2[sData$week_step[i], sData$week_step[i+1]] + 1
              }
            }
            
            #naming the nodes in the sankey diagram and adding a new node 
            #which signifies the situations when after a step a person jumped to a different week or ended the course 
            nodes <- data.frame("name" = steps, stringsAsFactors = FALSE)
            nodes <- rbind(nodes, data.frame("name" = "different week/ended course"))
            nodes$color <- colorRampPalette(c("aliceblue", "darkblue"))(nrow(nodes))
            
            #creating the links data frame to create the links in the sankey diagram
            links <- data.frame("source" = numeric(), "target" = numeric(), "value" = numeric(), "type" = character(), "color" = character())
            
            #populating the links data frame with the sources, targets and values from the table
            # I chose 10 as a threshold from when to start displaying the links, not to become that cluttered
            for(i in 1:(nrow(nodes)-1)){
              for(j in 1:(nrow(nodes)-1)){
                if(m1[i, j] > 10){
                  links <- rbind(links, data.frame("source" = i-1, "target" = j-1, "value" = m1[i, j], "type" = nodes[i, 1], "color" = nodes$color[i]))
                }
              }
            }
            
            #calculating the values between a step node and the other node - how many persons went from a step to a different week or ended course
            #again used 10 as threshold not to display all the lines as it becomes very cluttered
            for(i in 1:(nrow(nodes)-1)){
              s <- 0
              for(j in 1:(nrow(nodes)-1)){
                s<-s+m2[i,j]
              }
              if(i == nrow(nodes)-1){
                s <- s - m2[i, 1]
              }
              if(s>10){
                links <- rbind(links, data.frame("source" = i-1, "target" = nrow(nodes)-1, "value" = s, "type" = nodes[i, 1], "color" = nodes$color[i]))
              }
            }
            
          #Sankey diagram for the forward learner paths
          #it shows how many learners go from one step to another (e.g. how many go from step 1.1 to 1.2, or how many jump to 1.3 etc)
          output$sankeyLearnerPathsWeek <- renderSankeyNetwork({
            
            #isolating the links that are going forward
            links <- links[links$source < links$target, ]
            
            #rendering the diagram
            getSankeyDiagram("Learner paths going forward through the week steps", nodes, links)
              
            })
          
          #sankey diagram for the backwards learner paths
          #it shows how many learners go from a step to a previous one (e.g. from 1.5 to 1.2)
          output$sankeyLearnerPathsWeekRev <- renderSankeyNetwork({
            
            #isolating the links that are going backwards
            links <- links[links$source >= links$target, ]
            
            #rendering the diagram
            getSankeyDiagram("Learner paths going backwards through the week steps", nodes, links)
          })
        })
      }
    })
    
    
#' Function used to generate Sankey diagram
#'
#' @param t title of the diagram
#' @param nodes nodes of the diagram
#' @param links  links between the nodes
#'
#' @return the Sankey diagram
    getSankeyDiagram <- function(t, nodes, links){
      p <- plot_ly(
        type = "sankey",
        domain = c(
          x =  c(0,1),
          y =  c(0,1)
        ),
        orientation = "h",
        valueformat = ".0f",
        valuesuffix = " learners",
        
        node = list(
          label = nodes$name,
          color = nodes$color,
          pad = 15,
          thickness = 15,
          line = list(
            color = "black",
            width = 0.5
          )
        ),
        
        link = list(
          color = links$color,
          source = links$source,
          target = links$target,
          value =  links$value,
          #label =  links$type,
          line = list(
            color = "black",
            width = 0.5
          )
        )
      ) %>%
        layout(
          title = t,
          font = list(
            size = 13
          )
        )%>%
        config(displayModeBar = F)
      
      return(p)
    }
    
  
  #END LEARNER PATHS TAB
  
  
    
    
  
  # Debug tool print statements.
  # output$debug <- renderText({
  # 	freqs <- list()
  # 	maxLength <- 0
  # 	startDays <- list()
  # 	for(i in c(1:length(names(enrolment_data)))){
  # 		learners <- enrolment_data[[names(enrolment_data)[i]]]
  # 		learners <- learners[which(learners$role == "learner"),]
  # 		signUpCount <- count(substr(as.character(learners$enrolled_at),start = 1, stop = 10))
  # 		dates <- list(seq.Date(from = as.Date(signUpCount$x[1]), to = as.Date(tail(signUpCount$x, n =1)), by = 1) , numeric())
  # 		if(length(dates[[1]]) > maxLength){
  # 			maxLength <- length(dates[[1]])
  # 		}
  # 		for(x in c(1:length(signUpCount$x))){
  # 			dates[[2]][[which(dates[[1]] == as.Date(signUpCount$x[x]))]] <- signUpCount$freq[[x]]
  # 		}
  # 		freqs[[i]] <- dates
  # 		startDay <- substr(as.character(course_data[[names(course_data)[i]]]$start_date),start = 1, stop = 10)
  # 		startDays[i] <- as.Date(startDay) - as.Date(signUpCount$x[1])
  # 	}
  # 	print(length(startDays))
  # })
  
  
  getPage<-function() {
    return(includeHTML("funnel.html"))
  }
  
  #   output$funnel <- renderChart2({
  #     chartDependency()
  #     plotData <- getFunnelOfParticipation(enrolment_data, step_data, comments_data, assignments_data, 
  #                                          input$startDate, input$endDate)
  #     funnel <- Highcharts$new()
  #     funnel$plotOptions (
  #       funnel = list(
  #         neckWidth = "23%",
  #         neckHeight = "32%",
  #         width = "68%",
  #         dataLabels = list(
  #           enabled = "true",
  #           style = list(
  #             fontSize = "8px"
  #           )
  #         )
  #       )
  #     )
  #     funnel$series (
  #       data = list(
  #         list(plotData[1,1], plotData[1,2]),
  #         list(plotData[2,1], plotData[2,2]),
  #         list(plotData[3,1], plotData[3,2]),
  #         list(plotData[4,1], plotData[4,2]),
  #         list(plotData[5,1], plotData[5,2])
  #       ),
  #       type = "funnel",
  #       name = "learners"
  #     )
  #     return(funnel)
  #   })
  # 
  #   
  
  
  
  # createFunnelChart <- function () {
  # 	plotData <- getFunnelOfParticipation(enrolment_data, step_data, comments_data, assignments_data, 
  # 																			 startDate, endDate)
  # 	funnel <- Highcharts$new()
  # 	funnel$plotOptions (
  # 		funnel = list(
  # 			neckWidth = "23%",
  # 			neckHeight = "32%",
  # 			width = "68%",
  # 			dataLabels = list(
  # 				enabled = "true",
  # 				style = list(
  # 					fontSize = "8px"
  # 				)
  # 			)
  # 		)
  # 	)
  # 	funnel$series (
  # 		data = list(
  # 			list(plotData[1,1], plotData[1,2]),
  # 			list(plotData[2,1], plotData[2,2]),
  # 			list(plotData[3,1], plotData[3,2]),
  # 			list(plotData[4,1], plotData[4,2]),
  # 			list(plotData[5,1], plotData[5,2])
  # 		),
  # 		type = "funnel",
  # 		name = "learners"
  # 	)
  # 	funnel$addAssets(js = "http://code.highcharts.com/modules/funnel.js")
  # 	funnel$save("funnel.html", cdn = FALSE)
  # }
  
  
  
}